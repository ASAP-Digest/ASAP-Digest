---
description: 
globs: 
alwaysApply: true
---
# WordPress Class Organization v1.3

*(Self-correction: Added v1.1, updated Section 5 with global namespace instantiation rules; v1.2 Added reasoning logging for moves; v1.3 Added Section 5.C for constructor recursion prevention)*

Ensures consistent class organization, prevents namespace conflicts, maintains clean file structure, and enforces correct dependency loading order and instantiation patterns in WordPress plugins. This rule helps prevent common issues like duplicate classes, incorrect file paths, namespace mismatches, and "Class not found" or memory exhaustion fatal errors.

**When to Apply:**
- Creating new classes
- Moving existing classes
- Refactoring plugin structure
- Debugging class loading issues or fatal errors related to instantiation
- Adding `require_once` or `include_once` for class files

## 1. One Class, One Location

Each class MUST exist in only one file location within the plugin.

```php
// CORRECT
// /admin/class-admin-ui.php
namespace ASAPDigest\Admin;
class ASAP_Digest_Admin_UI { }

// INCORRECT - Same class defined in two locations
// /admin/class-admin-ui.php
// /includes/class-admin-ui.php
```

## 2. Directory Structure

Follow a logical directory structure reflecting the class's purpose.

```text
your-plugin/
├── admin/           # Admin UI classes
├── includes/        # Core functionality
│   ├── api/        # API endpoints
│   └── db/         # Database operations
└── templates/       # View templates
```

## 3. File Paths & Requires

Use `plugin_dir_path(__FILE__)` for reliable path generation when requiring files. Ensure the path points to the single correct location defined in Section 1. **See Section 6 for mandatory loading order checks.**

```php
// CORRECT
require_once plugin_dir_path(__FILE__) . 'admin/class-admin-ui.php';

// INCORRECT (Assuming the class is actually in admin/)
// require_once plugin_dir_path(__FILE__) . 'includes/class-admin-ui.php';
```

## 4. Namespace Structure

Namespaces MUST align with the directory structure relative to the plugin's root namespace (e.g., `ASAPDigest`).

```php
// CORRECT - Namespace matches directory
// In admin/class-admin-ui.php
namespace ASAPDigest\Admin;

// In includes/api/class-rest-auth.php
namespace ASAPDigest\API;

// INCORRECT - Namespace doesn't match location
// In admin/class-admin-ui.php
// namespace ASAPDigest\Core; // Should be ASAPDigest\Admin
```

## 5. Class Loading & Instantiation

### A. Within a Namespaced File
Use `use` statements to import other namespaced classes.

```php
// CORRECT (Inside a file like 'includes/class-core.php' which has 'namespace ASAPDigest\Core;')
namespace ASAPDigest\Core;

use ASAPDigest\Admin\ASAP_Digest_Admin_UI;
use ASAPDigest\API\ASAP_Digest_REST_Auth;

class Core {
    public function __construct() {
        // Example: if Admin_UI were being instantiated here
        // $admin_ui = new ASAP_Digest_Admin_UI(); 
        // $auth = new ASAP_Digest_REST_Auth();
    }
}

// INCORRECT (Inside a namespaced file)
// use ASAPDigest\Core\ASAP_Digest_Admin_UI; // Wrong namespace for Admin UI class
```

### B. From the Global Scope (Non-Namespaced Files)
When instantiating a namespaced class from a file that does **not** have its own `namespace` declaration (like the main plugin file `your-plugin.php`), you **MUST** use the fully qualified class name, preceded by a backslash (`\`). `use` statements have no effect in the global scope for instantiation.

```php
// CORRECT (In a file without 'namespace ...;' declaration, e.g., asapdigest-core.php)
require_once plugin_dir_path(__FILE__) . 'includes/api/class-rest-auth.php';

// Instantiate and assign to variable
$auth_instance = new \ASAPDigest\API\ASAP_Digest_REST_Auth();

// OR if only constructor side-effects are needed:
new \ASAPDigest\API\ASAP_Digest_REST_Auth();

// INCORRECT (In a file without 'namespace ...;')
// use ASAPDigest\API\ASAP_Digest_REST_Auth; // 'use' has no effect here for instantiation
// $instance = new ASAP_Digest_REST_Auth(); // Leads to "Class not found" or linter error
```

### C. Preventing Constructor Recursion (Singleton/Dependency Anti-Patterns) (NEW)
When a class (e.g., `DependentClass`) relies on a core singleton instance (e.g., `CoreClass::get_instance()`) or another dependency that is initialized by the `CoreClass`:

1.  **Anti-Pattern:** The constructor of `DependentClass` MUST NOT call `CoreClass::get_instance()` if `CoreClass` itself is responsible for instantiating `DependentClass` during `CoreClass`'s own construction phase. This creates a recursive loop if `CoreClass::get_instance()` tries to create a `new CoreClass()` while the initial `CoreClass` instance is not yet fully constructed and assigned to its static property.

    ```php
    // PROBLEMATIC PATTERN:
    // In CoreClass.php
    class CoreClass {
        private static $instance;
        private $dependent;
        public static function get_instance() {
            if (null === self::$instance) {
                self::$instance = new self(); // Triggers constructor
            }
            return self::$instance;
        }
        private function __construct() {
            // ... other initializations ...
            $this->dependent = new DependentClass(); // Instantiates DependentClass
        }
        public function get_db() { /* ... */ }
    }

    // In DependentClass.php
    class DependentClass {
        private $db;
        public function __construct() {
            // PROBLEM: CoreClass::get_instance() is called while CoreClass
            // might still be in its own __construct() method from the first call.
            // This leads to CoreClass::get_instance() trying to create a *new* CoreClass
            // because self::$instance isn't set yet from the *outermost* perspective.
            $core = CoreClass::get_instance(); 
            $this->db = $core->get_db(); 
        }
    }
    ```

2.  **Correct Pattern (Dependency Injection):** `CoreClass` (or the instantiating class) should pass the required dependencies (e.g., its own instance `$this`, or a specific component like `$this->database`) to the constructor of `DependentClass`.

    ```php
    // CORRECTED PATTERN (Dependency Injection):
    // In CoreClass.php
    class CoreClass {
        private static $instance;
        private $database;
        private $dependent;
        public static function get_instance() {
            if (null === self::$instance) {
                self::$instance = new self();
            }
            return self::$instance;
        }
        private function __construct() {
            $this->database = new DatabaseConnection();
            // ... other initializations ...
            // Pass the already initialized database object to DependentClass
            $this->dependent = new DependentClass($this->database); 
        }
        public function get_db() { return $this->database; }
    }

    // In DependentClass.php
    class DependentClass {
        private $db;
        // Accept dependency via constructor
        public function __construct(DatabaseConnection $db_instance) { 
            $this->db = $db_instance;
        }
    }
    ```
    This ensures `DependentClass` receives a fully formed dependency and breaks the recursive instantiation cycle.

## 6. Dependency Loading Order (`require_once`)

When adding a `require_once` or `include_once` statement for a PHP file containing a class definition (`ChildClass.php`):

1.  **MUST** inspect the class definition within `ChildClass.php` for an `extends ParentClass` clause. Use tools like `grep` or file reading if necessary.
2.  If an `extends` clause exists, **MUST** verify that the file defining `ParentClass` (e.g., `includes/class-parent.php`) is already included via `require_once` at an *earlier* point in the current file or execution flow.
3.  If `ParentClass.php` is not already included earlier, **MUST** add the `require_once plugin_dir_path(__FILE__) . 'includes/class-parent.php';` line *before* the `require_once plugin_dir_path(__FILE__) . 'includes/ChildClass.php\';` line.

**Example:**

```php
// CORRECT ORDER
require_once plugin_dir_path(__FILE__) . 'includes/api/class-rest-base.php';    // Parent class
require_once plugin_dir_path(__FILE__) . 'includes/api/class-rest-auth.php';    // Child class extends base
require_once plugin_dir_path(__FILE__) . 'includes/api/class-sync-token-controller.php\'; // Child class extends base

// INCORRECT ORDER - Would cause Fatal Error
// require_once plugin_dir_path(__FILE__) . 'includes/api/class-rest-auth.php';    // Child class
// require_once plugin_dir_path(__FILE__) . 'includes/api/class-rest-base.php';    // Parent class needed earlier
```

**Rationale:** This ensures PHP encounters and processes the parent class definition before it attempts to process a child class that depends on it, preventing "Class not found" fatal errors.

## 7. Moving Classes

When moving a class file:
1.  **Log Reason:** MUST document the reason for moving the class in internal logs or commit message.
2.  Search the entire plugin codebase for all references to the class (`grep -r "Your_Class_Name" .`).
3.  Update all `require_once` or `include_once` paths pointing to the old location. **Ensure dependency loading order (Section 6) and instantiation patterns (Section 5.C) are maintained after moving.**
4.  Update the `namespace` declaration within the moved class file itself to match its new directory structure.
5.  Update all `use` statements in other files that referenced the class's old namespace.
6.  Update any fully qualified instantiations (`new \Old\Namespace\Your_Class_Name()`) to use the new namespace (`new \New\Namespace\Your_Class_Name()`).
7.  Document the change (including reason) in `CHANGELOG.md`.

```markdown
## [1.0.1] - 2024-03-31
### Changed
- Moved `ASAP_Digest_Admin_UI` from `includes/` to `admin/` to better align with responsibility.
- Updated namespace from `ASAPDigest\Core` to `ASAPDigest\Admin`.
```

## 8. Common Issues This Prevents:
- Fatal errors from duplicate class definitions.
- Autoloader failures (if used) from mismatched namespaces.
- Confusion about class locations.
- Inconsistent plugin structure.
- Hard-to-track class dependencies.
- "Class not found" errors or linter warnings when instantiating from the global scope.
- **"Class not found" fatal errors due to incorrect `require_once` order for parent/child classes.**
- **Memory exhaustion fatal errors due to recursive class instantiation during plugin load or component initialization, especially involving singleton patterns.** (NEW)

## 9. Verification Steps:
1. Check for duplicate class files: `find . -name "class-*.php" | sort`.
2. Manually verify namespaces match directory structure in key classes.
3. Verify `require_once` paths are correct **and respect dependency order (Section 6)**.
4. **Review constructors of core/service classes to ensure they use dependency injection rather than direct `::get_instance()` calls for dependencies they themselves initialize (Section 5.C).** (NEW)
5. Test plugin activation and key functionality involving the classes.
6. Check PHP error logs for "Class not found" or memory exhaustion errors.
7. Run linters to check for "Undefined type" errors, especially in the main plugin file or other non-namespaced files.