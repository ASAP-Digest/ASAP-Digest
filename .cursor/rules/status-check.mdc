---
description: 
globs: 
alwaysApply: true
---
# Status Check Protocol (Project Status Report) v2.3

## 1. Protocol Restrictions
````markdown
A. Core Restrictions
- Status Check is a **READ-ONLY** operation concerning project files and state.
- Must NOT modify any project files (including roadmaps) or database.
- Must NOT initiate any work or state changes beyond its own logging.
- Must wait for explicit "IAW" or "BWS" command before any work initiation by the agent.
- **Execution Adherence:** Status Check execution MUST follow the single-response pattern for informational commands as defined in `<rule_execution_protocol>` Step 4.A.

B. Entity Creation Limits
- Only allowed to create `StatusCheck` and `StatusReport` entities in Server Memory for logging its own execution.
- The user-facing report content is derived from analyzing roadmap files and recent memory, not directly from general memory state.
- No task priority updates or external state modifications allowed.
````

## 2. Activation Methods
````text
A. Primary Triggers
- Command or alias "SC".
- Integration: Can be called by BWS/EWS protocols as part of their flow.
- Context: Used in WSMP (Work Session Management Protocol v2.10+) for state assessment.

B. Secondary Triggers
- Pre-session validation (if integrated into BWS).
- Post-session summary (if integrated into EWS).
- Ad-hoc project status queries.
````

## 3. Protocol Chain and Command Flow
````text
1. Status Check ("SC")
   - READ-ONLY operation regarding project files.
   - Creates `StatusCheck` and `StatusReport` entities for logging.
   - Reads and analyzes roadmap files (`docs/ROADMAP_TASKS.md`, LLM versions) and recent Server Memory using the WSMP priority logic.
   - Reports structured project status and exits.
   - **ONLY OUTPUT THE FINAL REPORT**

2. Work Initiation (Requires explicit command)
   - Must be triggered by "IAW" or "BWS".
   - Cannot be initiated by Status Check.

3. Command Hierarchy
   Status Check < Work Session < Task Execution

4. State Modification Rules
   - Status Check: READ-ONLY (for project files/state).
   - Work Session: Can modify state after explicit command.
   - Task Execution: Can modify state within active work session.
````

## 4. Protocol Integration Layer
````text
┌─────────────────────────────────────────┐
│         Protocol Integration            │
├─────────────────────────────────────────┤
│ 1. Status Check Protocol (This v2.3)    │
│ 2. Work Session Management Proto v2.10+ │ // Source of Priority Logic
│ 3. Server Memory Rules (v2.1+)          │
│ 4. Task Tracking Protocol               │
│ 5. Software Development Meta Protocol   │
│ 6. Rule Execution Protocol              │
│ 7. Format Time Protocol                 │ // For timestamp consistency
│ 8. Cross-Protocol Comms & Verification   │
│ 9. Audit Trail System                   │
└─────────────────────────────────────────┘
````

## 5. Status Check Implementation (Conceptual Steps)
````javascript
async function executeProjectStatusCheck_v2_3() {
    // 1. Initialize timestamp for report and logging
    const reportTimestamp = await mcp_mcp_datetime_get_datetime({ format: "datetime" });
    const formattedReportTime = await getFormattedTime(); // Use Format Time protocol/logic
    const logTimestamp = await mcp_mcp_datetime_get_datetime({ format: "log_compact" });

    // 2. Create status check entity in Server Memory
    await mcp_Server_Memory_create_entities({
        entities: [{
            name: `StatusCheck_${logTimestamp}`,
            entityType: "StatusCheck",
            observations: [
                `Project status check initiated at ${reportTimestamp}`,
                "Reading roadmap files and recent memory.",
            ]
        }]
    });

    // 3. Read Roadmap Files
    const roadmapTasksContent = await readFileContents('docs/ROADMAP_TASKS.md');
    // Potentially read LLM roadmap versions if needed for hierarchy/context
    // const mainRoadmapContent = await readFileContents('docs/ASAP_DIGEST_ROADMAP_LLM_X.md');

    // 4. Check Recent Server Memory
    const recentCompletions = await searchRecentMemory('TaskCompletion', 72);
    const activeErrors = await searchRecentMemory('Error', 0, ['status=active']);

    // 5. Parse and Analyze Data (WSMP Priority Logic)
    // Parse roadmapTasksContent to get all tasks with statuses (Emoji & Timestamp).
    // Identify sections based on parsing results and rules defined in Section 7.
    // *** BEGIN Priority Logic (Ref: WSMP v2.10, Sec 3.3) ***
    let priorityTask = null;
    let priorityReason = "No actionable tasks found.";

    // 5.1: Check Active Blocking Errors
    const blockedTaskInfo = findHighestPriorityBlockedTask(activeErrors, roadmapTasksContent); // Helper needed
    if (blockedTaskInfo) {
        priorityTask = blockedTaskInfo.task;
        priorityReason = `Blocked by Error: ${blockedTaskInfo.errorSummary}`;
    }

    // 5.2: Check Paused Tasks (if no error)
    if (!priorityTask) {
        const pausedTask = findHighestPriorityTaskByStatus(roadmapTasksContent, '⏸️'); // Helper needed
        if (pausedTask) {
            priorityTask = pausedTask;
            priorityReason = "Paused session";
        }
    }

    // 5.3: Check Testing Tasks (if no error/paused)
    if (!priorityTask) {
        const testingTask = findHighestPriorityTaskByStatus(roadmapTasksContent, '🧪'); // Helper needed
        if (testingTask) {
            priorityTask = testingTask;
            priorityReason = "Testing Active";
        }
    }

    // 5.4: Check Deepest In Progress (if no error/paused/testing)
    if (!priorityTask) {
        const inProgressTask = findDeepestTaskByStatus(roadmapTasksContent, '🔄'); // Helper needed
        if (inProgressTask) {
            priorityTask = inProgressTask;
            priorityReason = "Deepest Active Task";
        }
    }

    // 5.5: Check Pending Testing (if no error/paused/testing/in progress)
    if (!priorityTask) {
        const pendingTestTask = findHighestPriorityTaskByStatus(roadmapTasksContent, '🔬'); // Helper needed
        if (pendingTestTask) {
            priorityTask = pendingTestTask;
            priorityReason = "Pending Testing (Requires ST)"; // Special reason
        }
    }

    // 5.6: Check Pending Tasks (if none of the above)
    if (!priorityTask) {
        const pendingTask = findHighestPriorityTaskByStatus(roadmapTasksContent, '⏳'); // Helper needed
        if (pendingTask) {
            priorityTask = pendingTask;
            priorityReason = "Next Pending Task";
        }
    }
    // *** END Priority Logic ***

    // Extract other report data (completed, testing pipeline, blocked list etc.)
    const reportData = parseRoadmapsAndMemoryForReport(roadmapTasksContent, recentCompletions, activeErrors, priorityTask, priorityReason); // Modified Helper

    // 6. Generate Structured Report (User Facing)
    const userReport = formatUserReport_v2_3(reportData, formattedReportTime); // Use formatted time and updated structure

    // 7. Create status report entity in Server Memory
    await mcp_Server_Memory_create_entities({
        entities: [{
            name: `StatusReport_${logTimestamp}`,
            entityType: "StatusReport",
            observations: [
                `Report generated at ${reportTimestamp}`,
                `Summary: ${reportData.summary}`, // Store a brief summary
                `PriorityTask: ${reportData.priorityTask?.id || 'None'}`,
                `PriorityReason: ${reportData.priorityReason || 'N/A'}`,
                `BlockedTasksCount: ${reportData.blockedTasks?.length || 0}`,
                `PendingTestingCount: ${reportData.pendingTestingTasks?.length || 0}`,
                `ActiveTestingCount: ${reportData.activeTestingTasks?.length || 0}`,
            ]
        }]
    });

    // 8. Return the formatted user report
    return userReport;
}

// Helper function placeholders (implementation requires specific parsing logic)
async function readFileContents(filePath) { /* ... use read_file ... */ }
async function searchRecentMemory(entityType, hoursAgo, filters = []) { /* ... use mcp_Server_Memory_search_nodes ... */ }
async function getFormattedTime() { /* ... use format-time.mdc logic ... */ }
function findHighestPriorityBlockedTask(activeErrors, roadmapContent) { /* ... logic to link errors to tasks and find highest prio ... */ }
function findHighestPriorityTaskByStatus(roadmapContent, statusEmoji) { /* ... parse roadmap, filter by emoji, find highest prio based on order ... */ }
function findDeepestTaskByStatus(roadmapContent, statusEmoji) { /* ... parse roadmap, filter by emoji, determine hierarchy, find deepest ... */ }
function parseRoadmapsAndMemoryForReport(roadmapContent, recentCompletions, activeErrors, priorityTask, priorityReason) { /* ... parsing logic for report sections ... */ }
function formatUserReport_v2_3(reportData, formattedReportTime) { /* ... formatting logic using Markdown tables etc., reflecting updated priority section ... */ }
````

## 6. Information Sources Hierarchy
````text
1.  **Primary:** `docs/ROADMAP_TASKS.md` (for detailed task status and timestamps).
2.  **Secondary:**
    -   Server Memory:
        -   `TaskCompletion` entities (last 72h)
        -   Active `Error` entities (for priority determination and details)
        -   Potentially `Task` entities for state entry timestamps if not in roadmap.
    -   `docs/ASAP_DIGEST_ROADMAP_LLM_*.md` (or primary if not split): For overall context and task hierarchy (Major Task Group, Parent Subtask).
    -   Current Timestamp (`format-time.mdc`): For defining the "recent" window and report time.
````

## 7. Status Report Structure & Logic
The user-facing output MUST follow this structure, with the `🎯 Current Priority` section reflecting the logic from Section 5, Step 5:

````markdown

---
# **`📅 Status Check Report (MM.DD.YY | HH:MM AM/PM TimeZone)`**
---

### **`✅ Recently Completed (Last 72h):`**
  *   `[Task Name]` _(Completed: MM.DD.YY | HH:MM AM/PM TimeZone)_
  *   _(If none: ✨ No tasks completed recently.)_

---

### **`🔬🧪 Testing Pipeline:`**
  *   **`🔬 Pending Initiation:`**
      *   Priority? [Yes/No] - `[Task Name]` _(Entered Queue: [MM.DD.YY | HH:MM AM/PM TimeZone])_
      *   _(If none: 👍 None pending initiation.)_
  *   **`🧪 Actively Testing:`**
      *   `[Task Name]` _(Started: [MM.DD.YY | HH:MM AM/PM TimeZone])_
      *   _(If none: 👍 None actively testing.)_

---

### **`🎯 Current Priority:`**
  *   **`[Emoji]`** **`[Task Name]`**
      *   _Reason:_ **`[Determined Reason from WSMP Logic: e.g., "Testing Active", "Paused Session", "Blocked by Error: [Summary]", "Deepest Active Task", "Pending Testing (Requires ST)", "Next Pending Task"]`**
      *   _(If status is 🔬, add: ➡️ Use `ST [TaskID]` or `ST` to initiate testing.)_

---

### **`⏳ Upcoming Tasks (Next 3-5 Pending After Priority):`**
  *   `[Task Name]`
  *   `[Task Name]`
  *   `[Task Name]`
  *   _(If none: 👍 No pending tasks after priority.)_

---

### **`❌ Blocked Tasks:`**
  *   `[Task Name]` _(Reason: [If available from Error entity])_
  *   _(If none: 👍 No blocked tasks.)_

---

### **`⚙️ Overall Context:`**
  *   _Working within:_ `[Parent Subtask Name]` > **`[Priority Task Name]`** _(If applicable)_

---

````

## 8. Error Prevention and Handling
````text
-   Gracefully handle errors during file reading (`read_file`) or memory searches (`mcp_Server_Memory_search_nodes`).
-   If `ROADMAP_TASKS.md` cannot be read or parsed, the report should indicate this failure clearly.
-   Log any errors encountered during the status check itself into a relevant `Error` entity in Server Memory if possible, or include in the `StatusReport` entity's observations.
-   Ensure helper functions for parsing and priority determination handle edge cases (e.g., no tasks in a given state).
````