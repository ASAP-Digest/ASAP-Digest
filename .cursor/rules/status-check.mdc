---
description: 
globs: 
alwaysApply: true
---
# Status Check Protocol (Project Status Report) v2.4

## 1. Protocol Restrictions
```markdown
A. Core Restrictions
- Status Check is a **READ-ONLY** operation concerning project files and state.
- Must NOT modify any project files (including roadmaps) or database.
- Must NOT initiate any work or state changes beyond its own logging.
- Must wait for explicit "IAW" or "BWS" command before any work initiation by the agent.
- **Execution Adherence:** Status Check execution MUST follow the single-response pattern for informational commands as defined in `<rule_execution_protocol>` Step 4.A.

B. Entity Creation Limits
- Only allowed to create `StatusCheck` and `StatusReport` entities in Server Memory for logging its own execution.
- The user-facing report content is derived from analyzing roadmap files and recent memory, not directly from general memory state.
- No task priority updates or external state modifications allowed.
```

## 2. Activation Methods
```text
A. Primary Triggers
- Command or alias "SC".
- Integration: Can be called by BWS/EWS protocols as part of their flow.
- Context: Used in WSMP (Work Session Management Protocol v2.10+) for state assessment.

B. Secondary Triggers
- Pre-session validation (if integrated into BWS).
- Post-session summary (if integrated into EWS).
- Ad-hoc project status queries.
```

## 3. Protocol Chain and Command Flow
```text
1. Status Check ("SC")
   - READ-ONLY operation regarding project files.
   - Creates `StatusCheck` and `StatusReport` entities for logging.
   - Reads and analyzes roadmap files (`md-docs/ROADMAP_TASKS.md`, LLM versions) and recent Server Memory using the WSMP rank-aware priority logic.
   - Reports structured project status and exits.
   - **ONLY OUTPUT THE FINAL REPORT**

2. Work Initiation (Requires explicit command)
   - Must be triggered by "IAW" or "BWS".
   - Cannot be initiated by Status Check.

3. Command Hierarchy
   Status Check < Work Session < Task Execution

4. State Modification Rules
   - Status Check: READ-ONLY (for project files/state).
   - Work Session: Can modify state after explicit command.
   - Task Execution: Can modify state within active work session.
```

## 4. Protocol Integration Layer
```text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         Protocol Integration            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 1. Status Check Protocol (This v2.4)    ‚îÇ
‚îÇ 2. Work Session Management Proto v2.12+ ‚îÇ // Source of Rank-Aware Priority Logic
‚îÇ 3. Server Memory Rules (v2.1+)          ‚îÇ
‚îÇ 4. Task Tracking Protocol               ‚îÇ
‚îÇ 5. Software Development Meta Protocol   ‚îÇ
‚îÇ 6. Rule Execution Protocol              ‚îÇ
‚îÇ 7. Format Time Protocol                 ‚îÇ // For timestamp consistency
‚îÇ 8. Cross-Protocol Comms & Verification   ‚îÇ
‚îÇ 9. Audit Trail System                   ‚îÇ
‚îÇ 10. Roadmap Syntax Validation Proto v1.0+ ‚îÇ // Defines expected roadmap syntax (New)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## 5. Status Check Implementation (Conceptual Steps - Updated for Rank Awareness)
```javascript
async function executeProjectStatusCheck_v2_4() {
    // 1. Initialize timestamp for report and logging
    const reportTimestamp = await mcp_mcp-datetime_get_datetime({ format: "datetime" }); // Still get a standard format for logging
    // Use the updated format-time.mdc logic for the *user-facing* report time
    const formattedReportTime = await getFormattedTime_v1_1(); 
    const logTimestamp = await mcp_mcp-datetime_get_datetime({ format: "log_compact" });

    // 2. Create status check entity in Server Memory
    await mcp_Server_Memory_create_entities({
        entities: [{
            name: `StatusCheck_${logTimestamp}`,
            entityType: "StatusCheck",
            observations: [
                `Project status check initiated at ${reportTimestamp}`,
                "Reading roadmap files and recent memory.",
                "Applying Rank-Aware Priority Logic (v2.4)."
            ]
        }]
    });

    // 3. Read Roadmap Files
    const roadmapTasksContent = await readFileContents('md-docs/ROADMAP_TASKS.md');
    // Potentially read LLM roadmap versions if needed for hierarchy/context
    // const mainRoadmapContent = await readFileContents('md-docs/ASAP_DIGEST_ROADMAP_LLM_X.md');

    // 4. Check Recent Server Memory
    const recentCompletions = await searchRecentMemory('TaskCompletion', 72);
    const activeErrors = await searchRecentMemory('Error', 0, ['status=active']);

    // 5. Parse and Analyze Data (Rank-Aware WSMP Priority Logic)
    // Parse roadmapTasksContent to get all tasks with statuses, timestamps, AND ` ‚Ä¢ [ rnk:X ]` tags.
    // *** BEGIN Rank-Aware Priority Logic (Ref: WSMP v2.12+, Sec 3.3) ***
    let priorityTask = null;
    let priorityReason = "No actionable tasks found.";

    // 5.1: Check Active Blocking Errors
    const blockedTaskInfo = findHighestPriorityBlockedTask(activeErrors, roadmapTasksContent); // Helper needed
    if (blockedTaskInfo) {
        priorityTask = blockedTaskInfo.task; // Assumes helper returns {task: {...}, errorSummary: "..."}
        priorityReason = `Blocked by Error: ${blockedTaskInfo.errorSummary}`;
    }

    // 5.2: Check Paused Tasks (`‚è∏Ô∏è`)
    if (!priorityTask) {
        const pausedTask = findHighestPriorityTaskByStatus(roadmapTasksContent, '‚è∏Ô∏è'); // Helper needed
        if (pausedTask) {
            priorityTask = pausedTask;
            priorityReason = "Paused Session";
        }
    }

    // 5.3: Check Testing Tasks (`üß™`)
    if (!priorityTask) {
        const testingTask = findHighestPriorityTaskByStatus(roadmapTasksContent, 'üß™'); // Helper needed
        if (testingTask) {
            priorityTask = testingTask;
            priorityReason = "Testing Active";
        }
    }

    // 5.4: Check Highest Ranked Task (` ‚Ä¢ [ rnk:A ]` > ` ‚Ä¢ [ rnk:B ]` > ...)
    if (!priorityTask) {
        // Helper function needs to parse ` ‚Ä¢ [ rnk:X ]` tags and find the highest ranked non-completed/non-paused/non-testing task
        const rankedTask = findHighestExplicitlyRankedTask(roadmapTasksContent); // New helper needed
        if (rankedTask) {
            priorityTask = rankedTask;
            priorityReason = `Highest Ranked Task (rnk:${rankedTask.rank})`; // Include rank in reason
        }
    }

    // 5.5: Check Deepest In Progress (`üîÑ`) without rank
    if (!priorityTask) {
        // Helper needs modification to *exclude* tasks with a rank tag
        const inProgressTask = findDeepestTaskByStatus(roadmapTasksContent, 'üîÑ', { excludeRanked: true }); // Modified helper needed
        if (inProgressTask) {
            priorityTask = inProgressTask;
            priorityReason = "Deepest Active Task (Unranked)"; // Clarify reason
        }
    }

    // 5.6: Check Pending Testing (`üî¨`) without rank
    if (!priorityTask) {
        // Helper needs modification to *exclude* tasks with a rank tag
        const pendingTestTask = findHighestPriorityTaskByStatus(roadmapTasksContent, 'üî¨', { excludeRanked: true }); // Modified helper needed
        if (pendingTestTask) {
            priorityTask = pendingTestTask;
            priorityReason = "Pending Testing (Requires ST, Unranked)"; // Clarify reason
        }
    }

    // 5.7: Check Pending Tasks (`‚è≥`) without rank
    if (!priorityTask) {
        // Helper needs modification to *exclude* tasks with a rank tag
        const pendingTask = findHighestPriorityTaskByStatus(roadmapTasksContent, '‚è≥', { excludeRanked: true }); // Modified helper needed
        if (pendingTask) {
            priorityTask = pendingTask;
            priorityReason = "Next Pending Task (Unranked)"; // Clarify reason
        }
    }
    // *** END Rank-Aware Priority Logic ***

    // Extract other report data (completed, testing pipeline, blocked list etc.)
    const reportData = parseRoadmapsAndMemoryForReport(roadmapTasksContent, recentCompletions, activeErrors, priorityTask, priorityReason); // Modified Helper

    // 6. Generate Structured Report (User Facing)
    const userReport = formatUserReport_v2_4(reportData, formattedReportTime); // Use formatted time, updated report format

    // 7. Create status report entity in Server Memory
    await mcp_Server_Memory_create_entities({
        entities: [{
            name: `StatusReport_${logTimestamp}`,
            entityType: "StatusReport",
            observations: [
                `Report generated at ${reportTimestamp}`,
                `Summary: ${reportData.summary}`, // Store a brief summary
                `PriorityTask: ${reportData.priorityTask?.id || 'None'}`, 
                `PriorityReason: ${reportData.priorityReason || 'N/A'}`, 
                `DetectedRank: ${reportData.priorityTask?.rank || 'N/A'}`, // Store rank if applicable
                `BlockedTasksCount: ${reportData.blockedTasks?.length || 0}`,
                `PendingTestingCount: ${reportData.pendingTestingTasks?.length || 0}`,
                `ActiveTestingCount: ${reportData.activeTestingTasks?.length || 0}`,
            ]
        }]
    });

    // 8. Return the formatted user report
    return userReport;
}

// Helper function placeholders (implementation requires specific parsing logic, now including rank parsing)
async function readFileContents(filePath) { /* ... use read_file ... */ }
async function searchRecentMemory(entityType, hoursAgo, filters = []) { /* ... use mcp_Server_Memory_search_nodes ... */ }
// Reference the updated formatting logic
async function getFormattedTime_v1_1() { 
    // 1. Call mcp_mcp-datetime_get_datetime({ format: "iso" })
    // 2. Format the returned ISO string to "MM.DD.YY | HH:MM AM/PM PDT"
    // 3. Return the formatted string
}
function findHighestPriorityBlockedTask(activeErrors, roadmapContent) { /* ... logic to link errors to tasks and find highest prio ... */ }
function findHighestPriorityTaskByStatus(roadmapContent, statusEmoji, options = { excludeRanked: false }) { /* ... parse roadmap, filter by emoji, EXCLUDE ranked if options.excludeRanked, find highest prio based on order ... */ }
function findHighestExplicitlyRankedTask(roadmapContent) { /* ... parse roadmap, extract ` ‚Ä¢ [ rnk:X ]`, find highest ranked non-complete/paused/testing task ... */ }
function findDeepestTaskByStatus(roadmapContent, statusEmoji, options = { excludeRanked: false }) { /* ... parse roadmap, filter by emoji, EXCLUDE ranked if options.excludeRanked, determine hierarchy, find deepest ... */ }
function parseRoadmapsAndMemoryForReport(roadmapContent, recentCompletions, activeErrors, priorityTask, priorityReason) { /* ... parsing logic for report sections, now includes rank ... */ }
function formatUserReport_v2_4(reportData, formattedReportTime) { /* ... formatting logic using Markdown tables etc., reflect rank-aware priority reason ... */ }
```

## 6. Information Sources Hierarchy
```text
1.  **Primary:** `md-docs/ROADMAP_TASKS.md` (for detailed task status, timestamps, and ` ‚Ä¢ [ rnk:X ]` tags).
2.  **Secondary:**
    -   Server Memory:
        -   `TaskCompletion` entities (last 72h)
        -   Active `Error` entities (for priority determination and details)
        -   Potentially `Task` entities for state entry timestamps if not in roadmap.
    -   `md-docs/ASAP_DIGEST_ROADMAP_LLM_*.md` (or primary if not split): For overall context and task hierarchy (Major Task Group, Parent Subtask).
    -   Current Timestamp (`format-time.mdc`): For defining the "recent" window and report time.
```

## 7. Status Report Structure & Logic (Updated)
The user-facing output MUST follow this structure, with the `üìÖ Status Check Report (MM.DD.YY | HH:MM AM/PM TimeZone)` heading using the timestamp generated via `format-time.mdc`. The Priority section MUST reflect the rank-aware logic.

```markdown
---
## **`üìÖ Status Check Report (MM.DD.YY | HH:MM AM/PM TimeZone)`**
---

### **`‚úÖ Recently Completed (Last 72h):`**
  *   `[Task Name]` _(Completed: MM.DD.YY | HH:MM AM/PM TimeZone)_
  *   _(If none: ‚ú® No tasks completed recently.)_

---

### **`üî¨üß™ Testing Pipeline:`**
  *   **`üî¨ Pending Initiation:`**
      *   Priority? [Yes/No] - `[Task Name]` _(Rank: [X|N/A])_ _(Entered Queue: [MM.DD.YY | HH:MM AM/PM TimeZone])_
      *   _(If none: üëç None pending initiation.)_
  *   **`üß™ Actively Testing:`**
      *   `[Task Name]` _(Rank: [X|N/A])_ _(Started: [MM.DD.YY | HH:MM AM/PM TimeZone])_
      *   _(If none: üëç None actively testing.)_

---

### **`üéØ Current Priority:`**
  *   **`[Emoji]`** **`[Task Name]`** _(Rank: [X|N/A])_
      *   _Reason:_ **`[Determined Reason from Rank-Aware Logic: e.g., "Highest Ranked Task (rnk:A)", "Testing Active", "Paused Session", "Blocked by Error: [Summary]", "Deepest Active Task (Unranked)", "Pending Testing (Requires ST, Unranked)", "Next Pending Task (Unranked)"]`**
      *   _(If status is üî¨, add: ‚û°Ô∏è Use `ST [TaskID]` or `ST` to initiate testing.)_

---

### **`‚è≥ Upcoming Tasks (Next 3-5 Pending After Priority):`**
  *   `[Task Name]` _(Rank: [X|N/A])_
  *   `[Task Name]` _(Rank: [X|N/A])_
  *   `[Task Name]` _(Rank: [X|N/A])_
  *   _(If none: üëç No pending tasks after priority.)_

---

### **`‚ùå Blocked Tasks:`**
  *   `[Task Name]` _(Rank: [X|N/A])_ _(Reason: [If available from Error entity])_
  *   _(If none: üëç No blocked tasks.)_

---

### **`‚öôÔ∏è Overall Context:`**
  *   _Working within:_ `[Parent Subtask Name]` > **`[Priority Task Name]`** _(If applicable)_

---
```