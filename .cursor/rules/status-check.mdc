---
description: 
globs: 
alwaysApply: true
---
# Status Check Protocol (Project Status Report) v2.1

## 1. Protocol Restrictions
````markdown
A. Core Restrictions
- Status Check is a **READ-ONLY** operation concerning project files and state.
- Must NOT modify any project files (including roadmaps) or database.
- Must NOT initiate any work or state changes beyond its own logging.
- Must wait for explicit "IAW" or "BWS" command before any work initiation by the agent.

B. Entity Creation Limits
- Only allowed to create `StatusCheck` and `StatusReport` entities in Server Memory for logging its own execution.
- The user-facing report content is derived from analyzing roadmap files and recent memory, not directly from general memory state.
- No task priority updates or external state modifications allowed.
````

## 2. Activation Methods
````
A. Primary Triggers
- Command or alias "SC".
- Integration: Can be called by BWS/EWS protocols as part of their flow.
- Context: Used in WSMP (Work Session Management Protocol) for state assessment.

B. Secondary Triggers
- Pre-session validation (if integrated into BWS).
- Post-session summary (if integrated into EWS).
- Ad-hoc project status queries.
````

## 3. Protocol Chain and Command Flow
````
1. Status Check ("SC")
   - READ-ONLY operation regarding project files.
   - Creates `StatusCheck` and `StatusReport` entities for logging.
   - Reads and analyzes roadmap files (`docs/ROADMAP_TASKS.md`, `docs/ASAP_DIGEST_ROADMAP.md` or LLM versions) and recent Server Memory.
   - Reports structured project status and exits.
   - **ONLY OUTPUT THE FINAL REPORT**

2. Work Initiation (Requires explicit command)
   - Must be triggered by "IAW" or "BWS".
   - Cannot be initiated by Status Check.

3. Command Hierarchy
   Status Check < Work Session < Task Execution

4. State Modification Rules
   - Status Check: READ-ONLY (for project files/state).
   - Work Session: Can modify state after explicit command.
   - Task Execution: Can modify state within active work session.
````

## 4. Protocol Integration Layer
````
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Protocol Integration            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1. Status Check Protocol                â”‚
â”‚ 2. Work Session Management Protocol     â”‚
â”‚ 3. Memory Maintenance Protocol          â”‚
â”‚ 4. Task Tracking Protocol               â”‚
â”‚ 5. Software Development Meta Protocol   â”‚
â”‚ 6. Rule Execution Protocol              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
````

## 5. Status Check Implementation (Conceptual Steps)
````javascript
async function executeProjectStatusCheck() {
    // 1. Initialize timestamp for report and logging
    const reportTimestamp = await mcp_mcp_datetime_get_datetime({ format: "datetime" });
    const formattedTime = await mcp_mcp_datetime_get_datetime({ format: "log_compact" }); // Or use FT logic

    // 2. Create status check entity in Server Memory
    await mcp_Server_Memory_create_entities({
        entities: [{
            name: `StatusCheck_${formattedTime}`,
            entityType: "StatusCheck",
            observations: [
                `Project status check initiated at ${reportTimestamp}`,
                "Reading roadmap files and recent memory.",
            ]
        }]
    });

    // 3. Read Roadmap Files
    // Use read_file tool for 'docs/ROADMAP_TASKS.md'
    // Use read_file tool for 'docs/ASAP_DIGEST_ROADMAP.md' (or relevant LLM-split version)
    // Handle potential large file reads if necessary.
    const roadmapTasksContent = await readFileContents('docs/ROADMAP_TASKS.md');
    const mainRoadmapContent = await readFileContents('docs/ASAP_DIGEST_ROADMAP.md'); // Or LLM version

    // 4. Check Recent Server Memory (Last 24h)
    // Calculate timestamp for 24 hours ago
    // Use mcp_Server_Memory_search_nodes for TaskCompletion entities (by type and potentially observation content/timestamp)
    // Use mcp_Server_Memory_search_nodes for active Error entities
    const recentCompletions = await searchRecentMemory('TaskCompletion', 24);
    const activeErrors = await searchRecentMemory('Error', 0); // Search all active errors

    // 5. Parse and Analyze Data
    // Parse roadmapTasksContent to get all tasks with statuses (âœ…, ðŸ”„, â³, âŒ, ðŸ”¬, ðŸ§ª) and timestamps.
    // Identify sections based on parsing results and rules defined in Section 7.
    const reportData = parseRoadmapsAndMemory(roadmapTasksContent, mainRoadmapContent, recentCompletions, activeErrors, reportTimestamp);

    // 6. Generate Structured Report (User Facing)
    const userReport = formatUserReport(reportData, reportTimestamp);

    // 7. Create status report entity in Server Memory
    await mcp_Server_Memory_create_entities({
        entities: [{
            name: `StatusReport_${formattedTime}`,
            entityType: "StatusReport",
            observations: [
                `Report generated at ${reportTimestamp}`,
                `Summary: ${reportData.summary}`, // Store a brief summary or the full report text
                // Add key findings like priority task ID, number of blocked tasks etc.
            ]
        }]
    });

    // 8. Return the formatted user report
    return userReport;
}

// Helper function placeholders (implementation requires specific parsing logic)
async function readFileContents(filePath) { /* ... use read_file ... */ }
async function searchRecentMemory(entityType, hoursAgo) { /* ... use mcp_Server_Memory_search_nodes ... */ }
function parseRoadmapsAndMemory(roadmapTasksContent, mainRoadmapContent, recentCompletions, activeErrors, reportTimestamp) { /* ... parsing logic ... */ }
function formatUserReport(reportData, reportTimestamp) { /* ... formatting logic ... */ }

````
*(Note: The JavaScript is conceptual to illustrate the flow involving tool calls and logic)*

## 6. Information Sources Hierarchy
````
1.  **Primary:** `docs/ROADMAP_TASKS.md` (for detailed task status and timestamps).
2.  **Secondary:**
    -   Server Memory: For `TaskCompletion` entities (last 24h) and active `Error` entities.
    -   `docs/ASAP_DIGEST_ROADMAP.md` (or LLM versions): For overall context (Major Task Group).
    -   Current Timestamp (`mcp_mcp_datetime_get_datetime` or "FT"): For defining the "recent" window.
````

## 7. Status Report Structure & Logic
*(Self-correction: Added Testing Pipeline section and updated Priority Logic for v2.1)*
The user-facing output MUST follow this structure:

---
## **`ðŸ“… Status Check Report (Timestamp)`**
*(Timestamp format: "YYYY-MM-DD HH:MM:SS" or similar)*
---
### **`âœ… Recently Completed Tasks (Last 24h):`**
- Logic:
  - Get current time (T). Calculate T minus 24 hours (T-24).
  - Find tasks marked âœ… in `ROADMAP_TASKS.md` with a timestamp between T-24 and T.
  - Find `TaskCompletion` entities in Server Memory with a timestamp between T-24 and T.
  - Combine and deduplicate lists, sort by timestamp (most recent first).
  - Display the top 3-5 entries. If none, state "*No tasks completed in the last 24 hours.*"
- Format: `- Task Name (Completion Timestamp)`

### **`ðŸ§ª Testing Pipeline:`**
- Logic:
  - Find all tasks marked `ðŸ”¬` (Pending Testing) in `ROADMAP_TASKS.md`.
  - Find all tasks marked `ðŸ§ª` (Testing) in `ROADMAP_TASKS.md`.
  - List them separately. If none in a category, state "*None*".
- Format:
  - `ðŸ”¬ Pending User Initiation:`
  -   `- [Task Name] (Note if marked **PRIORITY**)`
  - `ðŸ§ª Actively Testing:`
  -   `- [Task Name]`

### **`ðŸŽ¯ Current / Operational Priority:`**
- Logic (Hierarchical):
  1. Find the first task marked `âŒ` in `ROADMAP_TASKS.md`. If found, this is the priority. Reason: "Blocked Task".
  2. If no blockers, search Server Memory for active `Error` entities. If found, the *first* error encountered is the priority. Reason: "Active Error". Include error details if possible.
  3. If no blockers or errors, find the first task marked `ðŸ”¬` in `ROADMAP_TASKS.md` (especially if marked `**PRIORITY:**`). If found, this is the priority. Reason: "Ready for Testing".
  4. If none of the above, find the first task marked `ðŸ§ª` in `ROADMAP_TASKS.md`. If found, this is the priority. Reason: "Active Testing".
  5. If none of the above, find the first task marked `ðŸ”„` in `ROADMAP_TASKS.md`. If found, this is the priority. Reason: "Next In Progress".
  6. If none of the above, find the first task marked `â³` in `ROADMAP_TASKS.md`. If found, this is the priority. Reason: "Next Pending".
- Format: `- [Emoji] Task Name (Reason for Priority)`

### **`â³ Upcoming Tasks:`**
- Logic:
  - Find the task identified as the current priority in the previous step within `ROADMAP_TASKS.md`.
  - List the next 3 tasks that appear *after* the priority task and are marked `â³`.
- Format: `- Task Name`

### **`âŒ Blocked Tasks:`**
- Logic: List all tasks marked `âŒ` in `ROADMAP_TASKS.md`. If none, state "*None*".
- Format: `- Task Name`

### **`âš™ï¸ Overall Context:`**
- Logic:
  - Identify the current priority task.
  - Find which major Task group (e.g., "Task 3: Develop Core Application Screens") from `ASAP_DIGEST_ROADMAP.md` (or LLM versions) this task belongs to.
- Format: `Currently working within: [Major Task Group Title]`
---

## 8. Error Prevention and Handling
````
-   Gracefully handle errors during file reading (`read_file`) or memory searches (`mcp_Server_Memory_search_nodes`).
-   If `ROADMAP_TASKS.md` cannot be read or parsed, the report should indicate this failure clearly.
-   Log any errors encountered during the status check itself into a relevant `Error` entity in Server Memory if possible, or include in the `StatusReport` entity's observations.
````

