---
description: 
globs: 
alwaysApply: true
---
# Cross-Protocol Communication & Verification Framework v2.0

## 1. Protocol State Management
```
A. State Transition Matrix
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Protocol        â”‚ Valid States           â”‚ Transition Rules         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Meta Protocol   â”‚ INIT, ACTIVE, END      â”‚ INIT â†’ ACTIVE            â”‚
â”‚ Rule Execution  â”‚ PLAN, EXEC, VERIFY     â”‚ PLAN â†’ EXEC              â”‚
â”‚ Task Tracking   â”‚ START, RUN, TEST, DONE â”‚ START â†’ RUN â†’ TEST â†’ DONEâ”‚
â”‚ Memory Manager  â”‚ READY, SYNC, LOCK      â”‚ READY â†’ SYNC             â”‚
â”‚ Testing/Verify  â”‚ PENDING, ACTIVE, DONE  â”‚ PENDING â†’ ACTIVE â†’ DONE  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
*(Self-correction: Added TESTING ('TEST') state to Task Tracking)*
*(Self-correction: Added Testing/Verification Protocol states)*

B. State Synchronization Rules
1. Pre-transition Verification
   - Current state validation
   - Dependency state check (e.g., Task must be RUN before TEST)
   - Resource availability check
   - Lock acquisition verification
   - **User approval check (for TEST â†’ DONE)**

2. Transition Execution
   - Atomic state updates
   - Cascading state changes
   - Rollback preparation
   - Event notification (`VERIFICATION_REQUESTED`, `VERIFICATION_COMPLETE`)

3. Post-transition Verification
   - New state validation
   - Dependency consistency
   - Resource cleanup
   - Lock release confirmation
   - **User approval confirmation logged**
```

## 2. Cross-Protocol Event System
```
A. Event Flow Control
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Event Type               â”‚ Priority Level â”‚ Handling Protocol        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ State Change             â”‚ CRITICAL       â”‚ State Manager            â”‚
â”‚ Task Update              â”‚ HIGH           â”‚ Task Tracker             â”‚
â”‚ Memory Sync              â”‚ MEDIUM         â”‚ Memory Manager           â”‚
â”‚ Verification Check       â”‚ HIGH           â”‚ Verification Chain       â”‚
â”‚ **Verification Requested** â”‚ **HIGH**       â”‚ **Testing Verification** â”‚
â”‚ **User Approval Result** â”‚ **CRITICAL**   â”‚ **Testing Verification** â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

B. Event Processing Pipeline
1. Event Generation
   - Source protocol identification
   - Event type classification
   - Priority assignment
   - Timestamp generation

2. Event Routing
   - Protocol dependency check
   - State compatibility verification
   - Resource availability check
   - Queue management

3. Event Execution
   - Handler selection
   - Context preparation
   - Execution monitoring
   - Result validation

4. Event Completion
   - Result propagation
   - State updates
   - Resource cleanup
   - Audit logging
```

## 3. Verification Chain System
```
A. Verification Levels
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Level           â”‚ Verification Type     â”‚ Required Checks                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ L1: Protocol    â”‚ State Integrity       â”‚ State, Events                    â”‚
â”‚ L2: Data        â”‚ Data Consistency      â”‚ DB, Memory, Files                â”‚
â”‚ L3: System      â”‚ System Integrity      â”‚ Resources, Locks                 â”‚
â”‚ L4: Security    â”‚ Access Control        â”‚ Auth, Permissions                â”‚
â”‚ **L5: User**    â”‚ **User Acceptance**   â”‚ **Explicit User Input/Approval** â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
*(Self-correction: Added L5 for User Acceptance)*

B. Verification Chain Execution
1. Pre-execution Chain
   - Protocol state verification
   - Resource availability check
   - Security context validation
   - Dependency verification
   - **User readiness check (for L5)**

2. Execution Chain
   - Operation atomic verification
   - State transition validation
   - Data consistency check
   - Event sequence validation
   - **User interaction logging (for L5)**

3. Post-execution Chain
   - Result verification
   - State consistency check
   - Resource cleanup verification
   - Audit trail validation
   - **User approval recorded (for L5)**
   - **L5 Dependency Check:** For L5 User Acceptance verification, MUST confirm the user approval action (e.g., `AC [TaskID]` command execution) and the corresponding `VerificationRequest` entity status (`APPROVED`) are correctly logged in the Audit Trail and Server Memory **before** related dependent actions (like `EWS COMPLETED` or final documentation updates) can proceed. Trigger UERP if checks fail.
```

## 4. Protocol Synchronization Framework
```
A. Synchronization Matrix
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Protocol Pair   â”‚ Sync Requirements         â”‚ Verification Points                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Meta â†” Rule     â”‚ State alignment           â”‚ Pre/Post State                      â”‚
â”‚ Rule â†” Task     â”‚ Task status sync          â”‚ Task Completion (Requires User Appr)â”‚
â”‚ Task â†” Memory   â”‚ Entity updates            â”‚ Data Consistency                    â”‚
â”‚ Task â†” Testing  â”‚ Task status (ğŸ”„ â†’ ğŸ§ª)     â”‚ Testing Entry Criteria              â”‚
â”‚ Testing â†” Task  â”‚ Task status (ğŸ§ª â†’ âœ…/ğŸ”„)  â”‚ User Approval Recorded (L5 Verify)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

B. Synchronization Process
1. Pre-sync Verification
   - Protocol readiness check
   - Resource availability
   - State compatibility
   - Lock acquisition

2. Sync Execution
   - Atomic updates
   - State propagation
   - Event generation
   - Error handling

3. Post-sync Verification
   - State consistency
   - Data integrity
   - Event completion
   - Lock release
```

## 5. Error Recovery System
```
A. Error Classification
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Error Type      â”‚ Recovery Strategy  â”‚ Verification Req   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ State Error     â”‚ State rollback     â”‚ Full chain verify  â”‚
â”‚ Data Error      â”‚ Data restoration   â”‚ Data integrity     â”‚
â”‚ Event Error     â”‚ Event replay       â”‚ Event sequence     â”‚
â”‚ Sync Error      â”‚ Resynchronization  â”‚ Cross-protocol     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

B. Recovery Process
1. Error Detection
   - Error classification
   - Impact assessment
   - Recovery strategy selection
   - Resource preparation

2. Recovery Execution
   - State restoration
   - Data recovery
   - Event replay
   - Sync repair

3. Recovery Verification
   - State validation
   - Data integrity check
   - Event sequence verify
   - System consistency
```

## 6. Audit Trail System
```
A. Audit Components
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Component       â”‚ Tracking Level     â”‚ Verification Req   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ State Changes   â”‚ FULL              â”‚ State Chain        â”‚
â”‚ Events         â”‚ FULL              â”‚ Event Sequence     â”‚
â”‚ Data Updates   â”‚ DELTA             â”‚ Data Integrity     â”‚
â”‚ Verifications  â”‚ SUMMARY           â”‚ Chain Completion   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

B. Audit Process
1. Event Recording
   - Timestamp capture
   - Context recording
   - State snapshot
   - Change delta

2. Trail Verification
   - Sequence validation
   - Integrity check
   - Completeness verify
   - Cross-reference

3. Audit Analysis
   - Pattern detection
   - Anomaly identification
   - Performance metrics
   - Security analysis
```

## 7. Implementation Examples

```javascript
// Example 1: Protocol State Transition
async function transitionProtocolState(protocol, newState) {
  const stateManager = await ProtocolStateManager.getInstance();
  
  // Pre-transition verification
  await stateManager.verifyTransition(protocol, newState);
  
  // Execute transition with event generation
  const event = await stateManager.transition(protocol, newState);
  
  // Post-transition verification
  await VerificationChain.verify(event);
  
  // Update audit trail
  await AuditTrail.record(event);
}

// Example 2: Cross-Protocol Event Handling
async function handleCrossProtocolEvent(event) {
  const eventSystem = await CrossProtocolEventSystem.getInstance();
  
  // Event validation and routing
  await eventSystem.validateEvent(event);
  const targetProtocols = await eventSystem.determineTargets(event);
  
  // Execute event chain with verification
  for (const protocol of targetProtocols) {
    const result = await eventSystem.executeEvent(event, protocol);
    await VerificationChain.verify(result);
  }
  
  // Sync protocol states
  await ProtocolStateManager.syncStates(targetProtocols);
}

// Example 3: Verification Chain Execution
async function executeVerificationChain(operation) {
  const verificationChain = await VerificationChainSystem.getInstance();
  
  // Pre-execution verification
  const preVerify = await verificationChain.preExecute(operation);
  if (!preVerify.success) {
    throw new VerificationError(preVerify.error);
  }
  
  // Execute with monitoring
  const result = await operation.execute();
  
  // Post-execution verification
  const postVerify = await verificationChain.postExecute(result);
  if (!postVerify.success) {
    await operation.rollback();
    throw new VerificationError(postVerify.error);
  }
  
  return result;
}
```

## 8. Usage Instructions

1. **Protocol State Management:**
   - Always use state transition matrix
   - Verify state before transitions
   - Maintain state history
   - Handle state conflicts

2. **Event System Usage:**
   - Follow event priority levels
   - Implement proper routing
   - Ensure event completion
   - Maintain event log

3. **Verification Requirements:**
   - Execute all verification levels
   - Follow verification chain
   - Document verification results
   - Handle verification failures

4. **Recovery Procedures:**
   - Classify errors properly
   - Select appropriate strategy
   - Verify recovery success
   - Update audit trail
