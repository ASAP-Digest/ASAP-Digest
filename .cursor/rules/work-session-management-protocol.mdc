---
description: 
globs: 
alwaysApply: true
---
# Enhanced Work Session Management Protocol (WSMP) v2.12

*(Self-correction: Updated version to incorporate EAQ integration and fix section numbering)*

## 1. Protocol Integration Layer
*(Self-correction: Updated integration points for WSAP v2.8 and TVP v1.4)*
```text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         Protocol Integration            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 1. Software Development Meta Protocol   ‚îÇ
‚îÇ 2. Rule Execution Protocol              ‚îÇ
‚îÇ 3. Task Tracking Protocol               ‚îÇ // Roadmap Update Logic (Implicit)
‚îÇ 4. Memory Maintenance Protocol          ‚îÇ // Includes Server Memory Rules v2.1+
‚îÇ 5. Session Management Protocol (This)   ‚îÇ // WSMP v2.12 (Self-reference)
‚îÇ 6. Status Check Protocol (v2.3+)        ‚îÇ // Required for BWS context
‚îÇ 7. Cross-Protocol Comms & Verification   ‚îÇ
‚îÇ 8. Universal Error Resolution Protocol  ‚îÇ
‚îÇ 9. Audit Trail System                   ‚îÇ
‚îÇ 10. Testing & Verification Protocol v1.4+‚îÇ // Handles task verification flow, triggered by EWS/EAQ
‚îÇ 11. Work Session Activation Proto v2.9+ ‚îÇ // Defines trigger commands (IAW, ST, EAQ, BWS, EWS, RWS)
‚îÇ 12. critical-code-removal-protocol.mdc  ‚îÇ // Governs code deletion
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## 2. Activation Commands & Flow
*(Self-correction: Referenced updated WSAP v2.8)*
```text
A. Start New Session (BWS)
- Command: "Begin Work Session" or alias "BWS"
- Triggered By: Manual User Command (via WSAP v2.8+) - Requires preceding SC. Can also be triggered internally by RWS fallback.
- Purpose: Initiates a NEW tracked work session, targeting the highest priority task identified by the preceding Status Check or RWS fallback.
- Optional Parameters: Session Type (DEBUG, FEATURE, FIX, REFACTOR, TESTING).
    - **Note on REFACTOR:** If a `REFACTOR` session involves deleting existing code, the steps within `critical-code-removal-protocol.mdc` MUST be followed before executing the removal.

B. Save Session State (SWS)
- Command: "Save Work Session" or alias "SWS"
- Purpose: Creates a `WorkSessionSave` entity, pauses the active session.
- Optional Parameters: Save Reason.

C. Resume Work Session (RWS)
- Command: "Resume Work Session" or alias "RWS"
- Triggered By: Manual User Command (via WSAP v2.8+).
- Purpose: Resumes a specific saved session (`[saveSessionID]`) or initiates the hierarchy-aware fallback logic to determine the next action (potentially starting a new BWS targeting tasks in various states, including TESTING, or reporting status).
- Optional Parameters: `saveSessionID`.

D. End Session (EWS)
- Command: "End Work Session" or alias "EWS"
- Purpose: Formally closes the ACTIVE work session.
- Optional Parameters: Reason (NORMAL, INTERRUPTED, TESTING, COMPLETED, FAILED).

E. Current Session Status & Auto-Save (CWS)
- Command: "Current Working Session" or alias "CWS"
- Purpose: Reports status, summarizes progress, performs auto-save (SWS), resumes (RWS).
- Prerequisites: An active `WorkSession` must exist.

F. Enter Approval Queue (EAQ)
- Command: "Enter Approval Queue" or alias "EAQ"
- Triggered By: Manual User Command (via WSAP v2.8+).
- Purpose: Directly initiates the evidence gathering and approval request process (TVP v1.4+ Steps 4 & 5) for the `targetTask` of the active session.
- Prerequisites: Active `WorkSession` exists, `targetTask` state is `TESTING` (`üß™`).
```

## 3. Context Establishment & Session Lifecycle Management

### 3.1 Session Initiation (BWS)
*(Self-correction: Added check to prevent status change if task is already TESTING - Inherited from v2.10)*
1.  **Determine Trigger Source:** BWS is triggered manually by the user or via RWS fallback.
2.  **Acquire Context (Status Check):** Execute "Status Check" (SC v2.3+) *unless* triggered by RWS fallback which has already determined the target. This involves reading `md-docs/ROADMAP_TASKS.md` and potentially recent memory via tool calls.
3.  **Analyze SC Output & Select Target Task:**
    -   If triggered manually: Identify the `üéØ Current / Operational Priority` task from the *newly run* SC report. This is the `targetTask`.
    -   If triggered by RWS fallback: Use the `targetTask` determined by the RWS logic.
4.  **Timestamp:** Get current timestamp (`mcp_mcp_datetime_get_datetime` tool call).
5.  **Generate Session ID:** Create a unique session ID (See Section 6).
6.  **Entity Creation:** Create `WorkSession` entity in Server Memory (`mcp_Server_Memory_create_entities` tool call) including:
    - Start timestamp.
    - Session Type (from param or inferred, use TESTING if triggered by RWS fallback on a `üß™` task).
    - Target Task ID (`targetTask`).
    - Overall Context (from relevant SC or RWS analysis).
    - Link to the relevant `StatusCheck` entity (if applicable).
    - Status: `ACTIVE`.
7.  **Task Status Update (if applicable):**
    -   If the `targetTask` status was `PENDING` (`‚è≥`) or `BLOCKED` (`‚ùå` - only if selected due to linked `Error`), update its status to `ACTIVE` (`üîÑ`) in Server Memory (`mcp_Server_Memory_add_observations` or similar) and `md-docs/ROADMAP_TASKS.md` (`edit_file` tool call). Add observation noting the reason (e.g., "Targeting blocked task to resolve error").
    -   **If the `targetTask` status is already `TESTING` (`üß™`) (triggered via RWS fallback), DO NOT change its status.** The BWS session will proceed with the task in the `TESTING` state.
    -   **Execute State Synchronization Verification (BWS - Active/Testing):** MUST execute the sequence from `mandatory-post-update-state-synchronization-verification-protocol.mdc v1.0` comparing the Memory `Task` status (`ACTIVE` or `TESTING`) and the `md-docs/ROADMAP_TASKS.md` marker (`üîÑ` or `üß™`). This involves reading the file and memory state and comparing them. Trigger UERP on failure.
8.  **Verification:** Execute L1/L3 Verification Chain checks (internal state consistency checks).
9.  **Audit:** Record `SESSION_START` event in Audit Trail (conceptual logging).
10. **Feedback:** Confirm session start with the Session ID, explicitly stating the `targetTask` being worked on and its current status (`üîÑ` or `üß™`).

### 3.2 Save Work Session (SWS)
*(Self-correction: Added check for AWAITING_APPROVAL state)*
1.  **Identify Active Session:** Determine the currently active `WorkSession` entity. If none, report error.
2.  **Check Approval Status:** Verify the session does not have an `AWAITING_APPROVAL` observation (added by `EAQ` flow in TVP). If it does, report error "Cannot save session while awaiting user approval (AC/RC)." and stop.
3.  **Timestamp:** Get current timestamp (`mcp_mcp_datetime_get_datetime`).
4.  **Pre-Save Verification:** Execute L1/L2/L3 Verification Chain checks.
5.  **Generate Save ID:** Create a unique ID for the save state.
6.  **Entity Creation:** Attempt to create the `WorkSessionSave` entity in Server Memory.
7.  **Verify Entity Creation:** Immediately attempt to read the newly created entity.
8.  **Handle Verification Result:** Proceed if successful, abort SWS if failed.
9.  **Update Active Session:** (Only if verification succeeded) Add observation to active `WorkSession` entity: `Session paused by WSSave_[ID] at [Timestamp]`. Change status to `PAUSED`.
10. **Task Status Marker (Optional but Recommended):** (Only if verification succeeded) Update the primary active task (üîÑ or üß™) in `md-docs/ROADMAP_TASKS.md` to `‚è∏Ô∏è [Paused: SWS - Timestamp]`.
11. **Execute State Synchronization Verification (SWS - Paused):** MUST execute the sequence from `mandatory-post-update-state-synchronization-verification-protocol.mdc v1.0` comparing the Memory `Task` status (implicitly paused/linked to WSSave) and the `md-docs/ROADMAP_TASKS.md` `‚è∏Ô∏è` marker/timestamp. Trigger UERP on failure.
12. **Relation Creation:** (Only if verification succeeded) Link `WorkSessionSave` to relevant entities.
13. **Audit:** Record `SESSION_SAVE` event.
14. **Feedback:** Provide confirmation with `WorkSessionSave` ID.

### 3.3 Resume Work Session (RWS)
*(Self-correction: Added check for AWAITING_APPROVAL on resumed session)*
1.  **Check for Specific Save ID:** If `saveSessionID` parameter is provided:
    -   Attempt to retrieve the specified `WorkSessionSave` entity and its linked `WorkSession` using Server Memory tools (`mcp_Server_Memory_search_nodes` or `mcp_Server_Memory_open_nodes`).
    -   Verify the linked `WorkSession` status is `PAUSED` by inspecting its observations/state.
    -   **Check Approval Status:** Verify the linked `WorkSession` does NOT have an `AWAITING_APPROVAL` observation. If it does, report error "Cannot resume session; it was paused while awaiting user approval. Please resolve with AC/RC first." and stop.
    -   If successful (found, paused, not awaiting approval), proceed to Step 7 (Update Work Session for Resumption).
    -   If fails (not found, not paused, or awaiting approval), report error and proceed to Fallback Logic (Step 2).

2.  **Fallback Logic - Priority 1: Check for Active Blocking Errors:**
    -   Query Server Memory (`mcp_Server_Memory_search_nodes`) for `Error` entities with `status=active`.
    -   Check for explicit `blockedBy` relations linking active errors to non-`‚úÖ` `Task` entities.
    -   If found: Select the highest priority blocked task based on roadmap order or other criteria (`targetTask`). Proceed to Step 6 (Initiate BWS for Fallback).
    -   If not found, proceed to Step 3.

3.  **Fallback Logic - Priority 2: Check for Explicitly Paused (`‚è∏Ô∏è`):**
    -   Scan `md-docs/ROADMAP_TASKS.md` (`read_file` tool call) for any task marked `‚è∏Ô∏è`. Parse the content to identify these tasks.
    -   If found: Select the highest priority one based on roadmap order (`targetTask`). Proceed to Step 6 (Initiate BWS for Fallback).
    -   If not found, proceed to Step 4.

4.  **Fallback Logic - Priority 3: Check for Actively Testing (`üß™`):**
    -   Scan `md-docs/ROADMAP_TASKS.md` (`read_file` tool call) for any task marked `üß™`. Parse the content to identify these tasks.
    -   If found: Select the highest priority one based on roadmap order (`targetTask`). **Proceed to Step 6 (Initiate BWS for Fallback).**
    -   If not found, proceed to Step 5.

5.  **Fallback Logic - Priority 4: Find Deepest "In Progress" (`üîÑ`):**
    -   Scan `md-docs/ROADMAP_TASKS.md` (`read_file` tool call) for all tasks marked `üîÑ`. Parse the content and determine hierarchy (e.g., based on indentation or task ID structure).
    -   Select the `üîÑ` task that is **lowest/deepest** in the hierarchy (`targetTask`).
    -   If found: Proceed to Step 6 (Initiate BWS for Fallback).
    -   If not found, proceed to Step 5a.

5a. **Fallback Logic - Priority 5: Check for Pending Testing (`üî¨`):**
    -   Scan `md-docs/ROADMAP_TASKS.md` (`read_file` tool call) for any task marked `üî¨`. Parse the content.
    -   If found: Select the highest priority one based on roadmap order. **Report** its status (e.g., "`Task Y` is pending testing (`üî¨`). Use `ST [TaskID]` or `ST` to initiate.") and **stop the RWS process.**
    -   If not found, proceed to Step 5b.

5b. **Fallback Logic - Priority 6: Find Highest Priority "Pending" (`‚è≥`):**
    -   Scan `md-docs/ROADMAP_TASKS.md` (`read_file` tool call) for tasks marked `‚è≥`. Parse the content.
    -   Select the highest priority one based on roadmap order (`targetTask`).
    -   If found: Proceed to Step 6 (Initiate BWS for Fallback).
    -   If not found, proceed to Step 5c.

5c. **Fallback Logic - Priority 7: Handle Blocked/No Tasks (`‚ùå`, None):**
    -   If parsing `md-docs/ROADMAP_TASKS.md` reveals only `‚ùå` (without active linked error) or `‚úÖ` tasks remain, **Report** that no actionable tasks are available and **stop the RWS process.**

6.  **Initiate BWS for Fallback:** (If Steps 2, 3, 4, 5, or 5b identified a `targetTask`)
    -   Execute the logic from Section 3.1 (BWS), passing the determined `targetTask`. This will create a *new* `WorkSession` entity focused on the identified task. Stop RWS execution here, as BWS takes over.

7.  **Update Work Session for Resumption:** (If Step 1 successfully found a specific `saveSessionID` and paused session)
    -   Retrieve the linked `WorkSession` entity from Server Memory.
    -   Timestamp: Get current timestamp (`mcp_mcp_datetime_get_datetime` tool call).
    -   Update `WorkSession` status back to `ACTIVE` in Server Memory. Add observation about resumption referencing the `saveSessionID`.
    -   Restore Context (Informational): Log restored context based on `WorkSessionSave` entity data.
    -   Task Status Marker Update: Update roadmap task marker in `md-docs/ROADMAP_TASKS.md` from `‚è∏Ô∏è` back to the task's actual status (likely `üîÑ` or `üß™`) (`edit_file` tool call).
    -   **Execute State Synchronization Verification (RWS - Active/Testing):** MUST execute the sequence from `mandatory-post-update-state-synchronization-verification-protocol.mdc v1.0` comparing the Memory `Task` status (retrieved) and the updated `md-docs/ROADMAP_TASKS.md` marker (`üîÑ` or `üß™`). Trigger UERP on failure.
    -   Verification: Execute L1/L3 Verification Chain checks (internal state).
    -   Audit: Record `SESSION_RESUME` event (conceptual log).
    -   Feedback: Confirm session resumption, stating Session ID and priority task.

### 3.4 End Work Session (EWS)
*(Self-correction: Added check for AWAITING_APPROVAL state)*
1.  **Identify Active Session:** Determine the currently active `WorkSession` entity. Stop if none.
2.  **Check Approval Status:** Verify the session does not have an `AWAITING_APPROVAL` observation. If it does, report error "Cannot end session; it is awaiting user approval (AC/RC). Please resolve first." and stop.
3.  **Identify Primary Task:** Identify the primary `Task` entity being worked on. Verify it's `ACTIVE` (`üîÑ`) or `TESTING` (`üß™`). Stop if not.
4.  **Timestamp:** Get current timestamp.
5.  **Finalization Logic:** Based on the `Reason` parameter:
    -   **If `Reason` is `TESTING`:**
        -   **Trigger Testing Protocol (Step 1 - Auto-Initiation):** Execute the initial steps of `Testing & Verification Protocol v1.4+` for the primary task. This updates task to `PENDING_TESTING` (`üî¨`), creates `VerificationRequest`, executes state sync verification, logs audit, and notifies user.
        -   **Update Work Session:** Change `WorkSession` status to `ENDED`. Add observation: `Session ended. Reason: Development complete, task '[TaskID]' moved to PENDING_TESTING (üî¨).`. Set `endTime`.
        -   **Audit:** Record `SESSION_END`.
        -   **Feedback:** Confirm session end, task now pending testing (`ST`).
    -   **If `Reason` is `COMPLETED`:**
        -   **Re-Verify Approval Status (MUST):** Query Server Memory for the `VerificationRequest` linked to the primary `TaskID`. Verify its status is `APPROVED`. Halt/UERP if verification fails.
        -   **(Task Status handled by TVP):** The task status (`COMPLETED`, `‚úÖ`) should have already been set by `TVP v1.4+` upon user approval (`AC`). This step mainly finalizes the session context.
        -   **Update Documentation:** Update final documentation (`DEPLOYMENT_CHECKLIST.md`, etc.).
        -   **Update Work Session:** Change status to `ENDED`. Add observation: `Session ended. Reason: Task '[TaskID]' COMPLETED (verified).`. Set `endTime`.
        -   **Audit:** Record `SESSION_END`.
        -   **Feedback:** Confirm session end and task completion.
    -   **If `Reason` is `NORMAL`, `INTERRUPTED`, `FAILED`:**
        -   **Task Status:** Do not change primary task status (remains `üîÑ` or `üß™`). Add notes.
        -   **Update Work Session:** Change status to `ENDED`. Add observation: `Session ended. Reason: [Reason Param]`. Set `endTime`.
        -   **Audit:** Record `SESSION_END`.
        -   **Feedback:** Confirm session end, note reason and unchanged task status.
6.  **Verification:** Execute final L1/L2/L4 Verification Chain checks.

### 3.5 Current Working Session (CWS)
*(Self-correction: Added reporting of AWAITING_APPROVAL state)*
1.  **Identify Active Session:** Stop if none.
2.  **Timestamp:** Get current timestamp.
3.  **Gather Session Info:** Retrieve ID, Start Time, Type, Priority, Context. Check for `AWAITING_APPROVAL` observation.
4.  **Summarize Session Progress:** Query Memory for entities created after session start and linked to the session. Summarize findings.
5.  **Format Report:** Compile info into user report. **Clearly indicate if the session is currently `AWAITING_APPROVAL`**.
6.  **Trigger Auto-Save (SWS):** If *not* `AWAITING_APPROVAL`, execute SWS logic (Section 3.2) with reason "Auto-save via CWS". Record Save ID.
7.  **Trigger Auto-Resume (RWS):** If SWS was successful, execute RWS logic (Section 3.3) using the Save ID from the previous step.
8.  **Verification:** Ensure session status is correctly reported and restored to `ACTIVE` after SWS/RWS cycle (if applicable).
9.  **Audit:** Record `SESSION_STATUS_CHECK`, potentially `SESSION_SAVE`, `SESSION_RESUME` events.
10. **Feedback:** Present the formatted report (from step 5) to the user.

## 4. State Management & Synchronization
*(Self-correction: Added Error state and AWAITING_APPROVAL consideration)*
- Manages `WorkSession` entity states (`ACTIVE`, `PAUSED`, `ENDED`) and observations (e.g., `AWAITING_APPROVAL`).
- Creates/Manages `WorkSessionSave` entities.
- Coordinates with Task Tracking Protocol for roadmap updates (`üîÑ`, `‚è∏Ô∏è`, `‚úÖ`, `üî¨`, `üß™`, `‚ùå`).
- Utilizes Server Memory for session context, state persistence, and `Error` entity status.
- Employs Cross-Protocol Verification to ensure consistency.

## 5. Session Identification & Naming
*(No changes needed from v2.10)*
- **Session ID:** `WS_[Type]_[Timestamp(log_compact)]` (e.g., `WS_Feature_20240331_153100`, `WS_Testing_20250414_100000`)
- **Save ID:** `WSSave_[SessionIDShort]_[Timestamp(log_compact)]` (e.g., `WSSave_WSF240331_20240331_170000`)

## 6. Error Handling & Recovery (UERP Integration)
*(Self-correction: Added EAQ context errors)*
- Handles errors like no active session, failed verification, failed entity creation/read during SWS.
- Handles attempting `SWS`, `RWS`, or `EWS` on a session that is `AWAITING_APPROVAL`.
- Handles `EAQ` context errors (no active session, task not `üß™`).
- Uses UERP for critical failures.
- SWS includes verification step to prevent entering paused state if save failed.
- RWS includes comprehensive fallback logic for missing save states, inconsistencies, and prioritizes active blocking errors.

## 7. Verification Checklist (for this protocol)
*(Self-correction: Added checks for EAQ/AWAITING_APPROVAL)*
-   [ ] `BWS` logic accommodates being triggered by RWS fallback.
-   [ ] `BWS` correctly updates status for tasks starting from `‚è≥` or `‚ùå` (due to error).
-   [ ] `BWS` correctly handles starting a session for a task already in `üß™` state (maintains status).
-   [ ] `SWS` logic prevents saving if `AWAITING_APPROVAL` observation exists.
-   [ ] `RWS` fallback logic updated to trigger `BWS` for `üß™` tasks (Priority 3).
-   [ ] `RWS` logic unchanged for `üî¨` tasks (Priority 5 - reports and stops).
-   [ ] `RWS` logic prevents resuming a session saved while `AWAITING_APPROVAL`.
-   [ ] `EWS` logic prevents ending if `AWAITING_APPROVAL` observation exists.
-   [ ] `EWS` logic correctly triggers `TVP v1.4+` for `TESTING` reason.
-   [ ] `EWS` logic correctly re-verifies `VerificationRequest` status for `COMPLETED` reason.
-   [ ] `CWS` logic correctly reports `AWAITING_APPROVAL` status.
-   [ ] `CWS` logic correctly skips SWS/RWS if `AWAITING_APPROVAL`.
-   [ ] State Synchronization Verification is executed at all required points.
-   [ ] Protocol integration layer lists correct protocol versions (`SC v2.3+`, `TVP v1.4+`, `WSAP v2.8+`, `Memory v2.1+`, `WSMP v2.12`).
-   [ ] Formatting adheres to `rule-formatting-protocol.mdc`.

## 8. Usage Instructions
*(Self-correction: Added EAQ explanation)*
-   **Starting Work:** Always initiate workflow with `IAW` first. Then, use `RWS` (which handles complex fallback including error checking, resuming paused/active work, targeting testing tasks, or starting pending tasks), or use `BWS` directly *after* `SC` if you want to manually target the top priority from the status check.
-   **Interruptions:** Use `SWS` to pause work safely (cannot be used if awaiting approval).
-   **Resuming Work:** Use `RWS`. If a specific save state is known, provide its ID (`RWS [saveSessionID]`); otherwise, the protocol executes the full fallback logic to determine the best action (resume, start new session on active/paused/testing/pending/blocked task, or report pending testing status). Cannot resume a session paused while awaiting approval.
-   **Checking Progress:** Use `CWS` during an active session. Reports progress and indicates if awaiting approval.
-   **Submitting Testing Task for Approval:** From *within* an active session where the task is `üß™`, use `EAQ` to trigger the evidence gathering and user approval process.
-   **Ending Work:** Use `EWS` with the appropriate `Reason` (e.g., `TESTING` to move `üîÑ`->`üî¨`, `COMPLETED` after `AC` approval, `NORMAL` for other cases). Cannot be used if awaiting approval.

## 9. Implementation Examples (Conceptual)
*(Self-correction: Corrected section number)*
```javascript
// Example 1: Begin Work Session (BWS) - Conceptual JS
async function handleBWS_Conceptual(sessionType = "FEATURE", targetTaskDetails = null) {
  let scReportData, targetTask;

  if (!targetTaskDetails) {
    // Triggered manually, run SC
    // 1. Read md-docs/ROADMAP_TASKS.md using read_file tool
    // 2. Search recent Server Memory for TaskCompletion/Error entities using mcp_Server_Memory_search_nodes
    // 3. Parse roadmap and memory data to determine priority task using WSMP v2.12 logic
    // scReportData = parsed result containing priorityTask
    targetTask = scReportData.priorityTask;
    if (!targetTask) {
      console.error("BWS Error: No priority task identified by Status Check.");
      return;
    }
  } else {
    // Triggered by RWS fallback
    targetTask = targetTaskDetails;
  }

  // Determine current task status by reading roadmap or memory
  const currentTaskStatus = "/* Read status (e.g., 'PENDING', 'TESTING') from roadmap/memory */";
  const sessionActualType = (currentTaskStatus === 'TESTING') ? 'TESTING' : sessionType; // Set session type based on task

  // Get timestamp using mcp_mcp_datetime_get_datetime
  const startTime = "/* timestamp from tool */";
  const logTs = "/* log_compact timestamp from tool */";
  const sessionId = `WS_${sessionActualType}_${logTs}`;

  // Create WorkSession Entity in Server Memory using mcp_Server_Memory_create_entities
  // Include startTime, sessionActualType, targetTask.id, Status: ACTIVE

  // Task Status Update Logic
  if (currentTaskStatus === 'PENDING' || currentTaskStatus === 'BLOCKED') {
    // Update task status to ACTIVE in Server Memory using mcp_Server_Memory_add_observations
    // Update md-docs/ROADMAP_TASKS.md using edit_file to change emoji to üîÑ
    // Execute State Synchronization Verification (read memory/file, compare 'ACTIVE'/'üîÑ')
  } else if (currentTaskStatus === 'TESTING') {
    // No status change needed, session starts on testing task
    // Execute State Synchronization Verification (read memory/file, compare 'TESTING'/'üß™')
  }

  // Log SESSION_START to audit trail
  console.log(`Work Session ${sessionId} started for Task ${targetTask.id} with status ${currentTaskStatus === 'TESTING' ? 'TESTING' : 'ACTIVE'}.`);
}

// Example 2: Save Work Session (SWS) - Conceptual JS
async function handleSWS_Conceptual(activeSessionId, reason = "Manual Save") {
  // Retrieve active WorkSession entity using mcp_Server_Memory_search_nodes or open_nodes
  const activeSession = "/* Retrieved WorkSession entity */";

  // Check for AWAITING_APPROVAL observation
  if (activeSession.observations.includes("AWAITING_APPROVAL")) {
      console.error("SWS Error: Cannot save session while awaiting user approval.");
      return;
  }

  // Get timestamp using mcp_mcp_datetime_get_datetime
  const saveTime = "/* timestamp from tool */";
  const logTs = "/* log_compact timestamp from tool */";
  const saveId = `WSSave_${activeSessionId.split('_')[1]}_${logTs}`; // Simplified ID

  // Create WorkSessionSave entity using mcp_Server_Memory_create_entities
  // Verify creation by reading the entity back

  // If verification passed:
  // Update activeSession observations (add paused note) and set status to PAUSED using mcp_Server_Memory_add_observations
  // Update relevant task in md-docs/ROADMAP_TASKS.md to ‚è∏Ô∏è using edit_file
  // Execute State Synchronization Verification (compare memory/file status)
  // Create relations using mcp_Server_Memory_create_relations
  // Log SESSION_SAVE to audit trail
  console.log(`Work Session ${activeSessionId} saved as ${saveId}.`);
}

// Example 3: Resume Work Session (RWS) - Conceptual JS Fallback
async function handleRWS_Conceptual_Fallback() {
    // 1. Check for Active Blocking Errors (mcp_Server_Memory_search_nodes)
    // 2. Check for Paused Tasks (read_file md-docs/ROADMAP_TASKS.md, parse for ‚è∏Ô∏è)
    // 3. Check for Testing Tasks (read_file md-docs/ROADMAP_TASKS.md, parse for üß™) -> If found, targetTask = highest prio üß™; handleBWS_Conceptual(targetTask)
    // 4. Check for Deepest In Progress (read_file md-docs/ROADMAP_TASKS.md, parse for üîÑ, determine hierarchy) -> If found, targetTask = deepest üîÑ; handleBWS_Conceptual(targetTask)
    // 5. Check for Pending Testing (read_file md-docs/ROADMAP_TASKS.md, parse for üî¨) -> If found, report "Use ST [TaskID]" and STOP.
    // 6. Check for Highest Pending (read_file md-docs/ROADMAP_TASKS.md, parse for ‚è≥) -> If found, targetTask = highest prio ‚è≥; handleBWS_Conceptual(targetTask)
    // 7. Handle No Actionable Tasks (report and STOP)
}

```

## 10. Performance & Batching Considerations
*(Self-correction: Restored missing section)*
-   **Memory Queries:** Frequent or complex Server Memory searches (`mcp_Server_Memory_search_nodes`) within fallback logic (especially RWS) can impact performance. Optimize queries where possible.
-   **Roadmap Parsing:** Reading and parsing large roadmap files repeatedly can be inefficient. Consider caching parsed roadmap state internally if performance becomes an issue, but ensure cache invalidation logic is robust.
-   **Batching (Future):** For extremely large projects or complex sessions, consider future enhancements for batching state updates to Server Memory or roadmap files, although this adds significant complexity to state management and error recovery.

