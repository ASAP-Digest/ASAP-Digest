---
description: 
globs: 
alwaysApply: true
---
# Enhanced Work Session Management Protocol (WSMP) v2.10

## 1. Protocol Integration Layer
*(Self-correction: Updated version number and integration points)*
````text
┌─────────────────────────────────────────┐
│         Protocol Integration            │
├─────────────────────────────────────────┤
│ 1. Software Development Meta Protocol   │
│ 2. Rule Execution Protocol              │
│ 3. Task Tracking Protocol               │ // Roadmap Update Logic (Implicit)
│ 4. Memory Maintenance Protocol          │ // Includes Server Memory Rules v2.1+
│ 5. Session Management Protocol (This)   │ // WSMP v2.10 (Self-reference)
│ 6. Status Check Protocol (v2.1+)        │ // Required for BWS context
│ 7. Cross-Protocol Comms & Verification   │
│ 8. Universal Error Resolution Protocol  │
│ 9. Audit Trail System                   │
│ 10. Testing & Verification Protocol v1.3+│ // Handles task verification flow, triggered by EWS
│ 11. Work Session Activation Proto v2.6+ │ // Defines trigger commands (IAW, ST, BWS, EWS, RWS) (Updated)
└─────────────────────────────────────────┘
````

## 2. Activation Commands & Flow
*(Self-correction: Minor clarification on RWS trigger)*
````text
A. Start New Session (BWS)
- Command: "Begin Work Session" or alias "BWS"
- Triggered By: Manual User Command (via WSAP v2.6+) - Requires preceding SC. Can also be triggered internally by RWS fallback.
- Purpose: Initiates a NEW tracked work session, targeting the highest priority task identified by the preceding Status Check or RWS fallback.
- Optional Parameters: Session Type (DEBUG, FEATURE, FIX, REFACTOR, TESTING).

B. Save Session State (SWS)
- Command: "Save Work Session" or alias "SWS"
- Purpose: Creates a `WorkSessionSave` entity, pauses the active session.
- Optional Parameters: Save Reason.

C. Resume Work Session (RWS)
- Command: "Resume Work Session" or alias "RWS"
- Triggered By: Manual User Command (via WSAP v2.6+).
- Purpose: Resumes a specific saved session (`[saveSessionID]`) or initiates the hierarchy-aware fallback logic to determine the next action (potentially starting a new BWS targeting tasks in various states, including TESTING, or reporting status).
- Optional Parameters: `saveSessionID`.

D. End Session (EWS)
- Command: "End Work Session" or alias "EWS"
- Purpose: Formally closes the ACTIVE work session.
- Optional Parameters: Reason (NORMAL, INTERRUPTED, TESTING, COMPLETED, FAILED).

E. Current Session Status & Auto-Save (CWS)
- Command: "Current Working Session" or alias "CWS"
- Purpose: Reports status, summarizes progress, performs auto-save (SWS), resumes (RWS).
- Prerequisites: An active `WorkSession` must exist.
````

## 3. Context Establishment & Session Lifecycle Management

### 3.1 Session Initiation (BWS)
*(Self-correction: Added check to prevent status change if task is already TESTING)*
1.  **Determine Trigger Source:** BWS is triggered manually by the user or via RWS fallback.
2.  **Acquire Context (Status Check):** Execute "Status Check" (SC v2.1+) *unless* triggered by RWS fallback which has already determined the target. This involves reading `docs/ROADMAP_TASKS.md` and potentially recent memory via tool calls.
3.  **Analyze SC Output & Select Target Task:**
    -   If triggered manually: Identify the `🎯 Current / Operational Priority` task from the *newly run* SC report. This is the `targetTask`.
    -   If triggered by RWS fallback: Use the `targetTask` determined by the RWS logic.
4.  **Timestamp:** Get current timestamp (`mcp_mcp_datetime_get_datetime` tool call).
5.  **Generate Session ID:** Create a unique session ID (See Section 5).
6.  **Entity Creation:** Create `WorkSession` entity in Server Memory (`mcp_Server_Memory_create_entities` tool call) including:
    - Start timestamp.
    - Session Type (from param or inferred, use TESTING if triggered by RWS fallback on a `🧪` task).
    - Target Task ID (`targetTask`).
    - Overall Context (from relevant SC or RWS analysis).
    - Link to the relevant `StatusCheck` entity (if applicable).
    - Status: `ACTIVE`.
7.  **Task Status Update (if applicable):**
    -   If the `targetTask` status was `PENDING` (`⏳`) or `BLOCKED` (`❌` - only if selected due to linked `Error`), update its status to `ACTIVE` (`🔄`) in Server Memory (`mcp_Server_Memory_add_observations` or similar) and `docs/ROADMAP_TASKS.md` (`edit_file` tool call). Add observation noting the reason (e.g., "Targeting blocked task to resolve error").
    -   **If the `targetTask` status is already `TESTING` (`🧪`) (triggered via RWS fallback), DO NOT change its status.** The BWS session will proceed with the task in the `TESTING` state.
    -   **Execute State Synchronization Verification (BWS - Active/Testing):** MUST execute the sequence from `Mandatory Post-Update State Synchronization Verification Protocol v1.0` comparing the Memory `Task` status (`ACTIVE` or `TESTING`) and the `docs/ROADMAP_TASKS.md` marker (`🔄` or `🧪`). This involves reading the file and memory state and comparing them. Trigger UERP on failure.
8.  **Verification:** Execute L1/L3 Verification Chain checks (internal state consistency checks).
9.  **Audit:** Record `SESSION_START` event in Audit Trail (conceptual logging).
10. **Feedback:** Confirm session start with the Session ID, explicitly stating the `targetTask` being worked on and its current status (`🔄` or `🧪`).

### 3.2 Save Work Session (SWS)
*(No changes needed from v2.9)*
````text
1.  **Identify Active Session:** Determine the currently active `WorkSession` entity. If none, report error.
2.  **Timestamp:** Get current timestamp (`mcp_mcp_datetime_get_datetime`).
3.  **Pre-Save Verification:** Execute L1/L2/L3 Verification Chain checks.
4.  **Generate Save ID:** Create a unique ID for the save state.
5.  **Entity Creation:** Attempt to create the `WorkSessionSave` entity in Server Memory.
6.  **Verify Entity Creation:** Immediately attempt to read the newly created entity.
7.  **Handle Verification Result:** Proceed if successful, abort SWS if failed.
8.  **Update Active Session:** (Only if verification succeeded) Add observation to active `WorkSession` entity: `Session paused by WSSave_[ID] at [Timestamp]`. Change status to `PAUSED`.
9.  **Task Status Marker (Optional but Recommended):** (Only if verification succeeded) Update the primary active task (🔄) in `docs/ROADMAP_TASKS.md` to `⏸️ [Paused: SWS - Timestamp]`.
9.a. **Execute State Synchronization Verification (SWS - Paused):** MUST execute the sequence from `Mandatory Post-Update State Synchronization Verification Protocol v1.0` comparing the Memory `Task` status (paused/linked) and the `docs/ROADMAP_TASKS.md` `⏸️` marker/timestamp. Trigger UERP on failure.
10. **Relation Creation:** (Only if verification succeeded) Link `WorkSessionSave` to relevant entities.
11. **Audit:** Record `SESSION_SAVE` event.
12. **Feedback:** Provide confirmation with `WorkSessionSave` ID.
````

### 3.3 Resume Work Session (RWS)
*(Self-correction: Updated Step 4 (Priority 3) to trigger BWS for TESTING tasks)*
````text
1.  **Check for Specific Save ID:** If `saveSessionID` parameter is provided:
    -   Attempt to retrieve the specified `WorkSessionSave` entity and its linked `WorkSession` using Server Memory tools (`mcp_Server_Memory_search_nodes` or `mcp_Server_Memory_open_nodes`).
    -   Verify the linked `WorkSession` status is `PAUSED` by inspecting its observations/state.
    -   If successful, proceed to Step 7 (Update Work Session for Resumption).
    -   If fails (not found, not paused), report error and proceed to Fallback Logic (Step 2).

2.  **Fallback Logic - Priority 1: Check for Active Blocking Errors:**
    -   Query Server Memory (`mcp_Server_Memory_search_nodes`) for `Error` entities with `status=active`.
    -   Check for explicit `blockedBy` relations linking active errors to non-`✅` `Task` entities.
    -   If found: Select the highest priority blocked task based on roadmap order or other criteria (`targetTask`). Proceed to Step 6 (Initiate BWS for Fallback).
    -   If not found, proceed to Step 3.

3.  **Fallback Logic - Priority 2: Check for Explicitly Paused (`⏸️`):**
    -   Scan `docs/ROADMAP_TASKS.md` (`read_file` tool call) for any task marked `⏸️`. Parse the content to identify these tasks.
    -   If found: Select the highest priority one based on roadmap order (`targetTask`). Proceed to Step 6 (Initiate BWS for Fallback).
    -   If not found, proceed to Step 4.

4.  **Fallback Logic - Priority 3: Check for Actively Testing (`🧪`):**
    -   Scan `docs/ROADMAP_TASKS.md` (`read_file` tool call) for any task marked `🧪`. Parse the content to identify these tasks.
    -   If found: Select the highest priority one based on roadmap order (`targetTask`). **Proceed to Step 6 (Initiate BWS for Fallback).**
    -   If not found, proceed to Step 5.

5.  **Fallback Logic - Priority 4: Find Deepest "In Progress" (`🔄`):**
    -   Scan `docs/ROADMAP_TASKS.md` (`read_file` tool call) for all tasks marked `🔄`. Parse the content and determine hierarchy (e.g., based on indentation or task ID structure).
    -   Select the `🔄` task that is **lowest/deepest** in the hierarchy (`targetTask`).
    -   If found: Proceed to Step 6 (Initiate BWS for Fallback).
    -   If not found, proceed to Step 5a.

5a. **Fallback Logic - Priority 5: Check for Pending Testing (`🔬`):**
    -   Scan `docs/ROADMAP_TASKS.md` (`read_file` tool call) for any task marked `🔬`. Parse the content.
    -   If found: Select the highest priority one based on roadmap order. **Report** its status (e.g., "`Task Y` is pending testing (`🔬`). Use `ST [TaskID]` or `ST` to initiate.") and **stop the RWS process.**
    -   If not found, proceed to Step 5b.

5b. **Fallback Logic - Priority 6: Find Highest Priority "Pending" (`⏳`):**
    -   Scan `docs/ROADMAP_TASKS.md` (`read_file` tool call) for tasks marked `⏳`. Parse the content.
    -   Select the highest priority one based on roadmap order (`targetTask`).
    -   If found: Proceed to Step 6 (Initiate BWS for Fallback).
    -   If not found, proceed to Step 5c.

5c. **Fallback Logic - Priority 7: Handle Blocked/No Tasks (`❌`, None):**
    -   If parsing `docs/ROADMAP_TASKS.md` reveals only `❌` (without active linked error) or `✅` tasks remain, **Report** that no actionable tasks are available and **stop the RWS process.**

6.  **Initiate BWS for Fallback:** (If Steps 2, 3, 4, 5, or 5b identified a `targetTask`)
    -   Execute the logic from Section 3.1 (BWS), passing the determined `targetTask`. This will create a *new* `WorkSession` entity focused on the identified task. Stop RWS execution here, as BWS takes over.

7.  **Update Work Session for Resumption:** (If Step 1 successfully found a specific `saveSessionID` and paused session)
    -   Retrieve the linked `WorkSession` entity from Server Memory.
    -   Timestamp: Get current timestamp (`mcp_mcp_datetime_get_datetime` tool call).
    -   Update `WorkSession` status back to `ACTIVE` in Server Memory. Add observation about resumption referencing the `saveSessionID`.
    -   Restore Context (Informational): Log restored context based on `WorkSessionSave` entity data.
    -   Task Status Marker Update: Update roadmap task marker in `docs/ROADMAP_TASKS.md` from `⏸️` back to `🔄` (`edit_file` tool call).
    -   **Execute State Synchronization Verification (RWS - Active):** MUST execute the sequence from `Mandatory Post-Update State Synchronization Verification Protocol v1.0` comparing the Memory `Task` status (`ACTIVE`) and the `docs/ROADMAP_TASKS.md` `🔄` marker. Trigger UERP on failure.
    -   Verification: Execute L1/L3 Verification Chain checks (internal state).
    -   Audit: Record `SESSION_RESUME` event (conceptual log).
    -   Feedback: Confirm session resumption, stating Session ID and priority task.
````

### 3.4 End Work Session (EWS)
*(No changes needed from v2.9)*
````text
1.  **Identify Active Session:** Determine the currently active `WorkSession` entity. Stop if none.
2.  **Identify Primary Task:** Identify the primary `Task` entity being worked on. Verify it's `ACTIVE` (`🔄`) or `TESTING` (`🧪`). Stop if not.
3.  **Timestamp:** Get current timestamp.
4.  **Finalization Logic:** Based on the `Reason` parameter:
    -   **If `Reason` is `TESTING`:**
        -   **Trigger Testing Protocol (Step 1 - Auto-Initiation):** Execute the initial steps of `Testing & Verification Protocol v1.3+` for the primary task. This updates task to `PENDING_TESTING` (`🔬`), creates `VerificationRequest`, executes state sync verification, logs audit, and notifies user.
        -   **Update Work Session:** Change `WorkSession` status to `ENDED`. Add observation: `Session ended. Reason: Development complete, task '[TaskID]' moved to PENDING_TESTING (🔬).`. Set `endTime`.
        -   **Audit:** Record `SESSION_END`.
        -   **Feedback:** Confirm session end, task now pending testing (`ST`).
    -   **If `Reason` is `COMPLETED`:**
        -   **Re-Verify Approval Status (MUST):** Query Server Memory for the `VerificationRequest` linked to the primary `TaskID`. Verify its status is `APPROVED`. Halt/UERP if verification fails.
        -   **(Task Status handled by TVP):** The task status (`COMPLETED`, `✅`) should have already been set by `TVP v1.3+` upon user approval (`AC`). This step mainly finalizes the session context.
        -   **Update Documentation:** Update final documentation (`DEPLOYMENT_CHECKLIST.md`, etc.).
        -   **Update Work Session:** Change status to `ENDED`. Add observation: `Session ended. Reason: Task '[TaskID]' COMPLETED (verified).`. Set `endTime`.
        -   **Audit:** Record `SESSION_END`.
        -   **Feedback:** Confirm session end and task completion.
    -   **If `Reason` is `NORMAL`, `INTERRUPTED`, `FAILED`:**
        -   **Task Status:** Do not change primary task status (remains `🔄` or `🧪`). Add notes.
        -   **Update Work Session:** Change status to `ENDED`. Add observation: `Session ended. Reason: [Reason Param]`. Set `endTime`.
        -   **Audit:** Record `SESSION_END`.
        -   **Feedback:** Confirm session end, note reason and unchanged task status.
5.  **Verification:** Execute final L1/L2/L4 Verification Chain checks.
````

### 3.5 Current Working Session (CWS)
*(No changes needed from v2.9)*
````text
1.  **Identify Active Session:** Stop if none.
2.  **Timestamp:** Get current timestamp.
3.  **Gather Session Info:** Retrieve ID, Start Time, Type, Priority, Context.
4.  **Summarize Session Progress:** Query Memory for entities created after session start and linked to the session. Summarize findings.
5.  **Format Report:** Compile info into user report.
6.  **Trigger Auto-Save (SWS):** Execute SWS logic (Section 3.2) with reason "Auto-save via CWS". Record Save ID.
7.  **Trigger Auto-Resume (RWS):** Execute RWS logic (Section 3.3) using the Save ID from the previous step.
8.  **Verification:** Ensure session status is correctly restored to `ACTIVE` after SWS/RWS cycle.
9.  **Audit:** Record `SESSION_STATUS_CHECK`, `SESSION_SAVE`, `SESSION_RESUME` events.
10. **Feedback:** Present the formatted report (from step 5) to the user.
````

## 4. State Management & Synchronization
*(Self-correction: Added Error state consideration)*
- Manages `WorkSession` entity states (`ACTIVE`, `PAUSED`, `ENDED`).
- Creates/Manages `WorkSessionSave` entities.
- Coordinates with Task Tracking Protocol for roadmap updates (`🔄`, `⏸️`, `✅`, `🔬`, `🧪`, `❌`).
- Utilizes Server Memory for session context, state persistence, and `Error` entity status.
- Employs Cross-Protocol Verification to ensure consistency.

## 5. Session Identification & Naming
*(No changes needed from v2.9)*
- **Session ID:** `WS_[Type]_[Timestamp(log_compact)]` (e.g., `WS_Feature_20240331_153100`, `WS_Testing_20250414_100000`)
- **Save ID:** `WSSave_[SessionIDShort]_[Timestamp(log_compact)]` (e.g., `WSSave_WSF240331_20240331_170000`)

## 6. Error Handling & Recovery (UERP Integration)
*(Self-correction: Added Error handling in RWS)*
- Handles errors like no active session, failed verification, failed entity creation/read during SWS.
- Uses UERP for critical failures.
- SWS includes verification step to prevent entering paused state if save failed.
- RWS includes comprehensive fallback logic for missing save states, inconsistencies, and prioritizes active blocking errors.

## 7. Verification Checklist (for this protocol)
*(Self-correction: Updated checks for v2.10)*
-   [ ] `BWS` logic accommodates being triggered by RWS fallback.
-   [ ] `BWS` correctly updates status for tasks starting from `⏳` or `❌` (due to error).
-   [ ] `BWS` correctly handles starting a session for a task already in `🧪` state (maintains status).
-   [ ] `SWS` logic unchanged.
-   [ ] `RWS` fallback logic updated to trigger `BWS` for `🧪` tasks (Priority 3).
-   [ ] `RWS` logic unchanged for `🔬` tasks (Priority 5 - reports and stops).
-   [ ] `EWS` logic unchanged.
-   [ ] State Synchronization Verification is executed at all required points.
-   [ ] Protocol integration layer lists correct protocol versions (`SC v2.1+`, `TVP v1.3+`, `WSAP v2.6+`, `Memory v2.1+`, `WSMP v2.10`).
-   [ ] Formatting adheres to `rule-formatting-protocol.mdc`.

## 8. Usage Instructions (New Section)
*(Self-correction: Updated RWS description)*
-   **Starting Work:** Always initiate workflow with `IAW` first. Then, use `RWS` (which handles complex fallback including error checking, resuming paused/active work, targeting testing tasks, or starting pending tasks), or use `BWS` directly *after* `SC` if you want to manually target the top priority from the status check.
-   **Interruptions:** Use `SWS` to pause work safely.
-   **Resuming Work:** Use `RWS`. If a specific save state is known, provide its ID (`RWS [saveSessionID]`); otherwise, the protocol executes the full fallback logic to determine the best action (resume, start new session on active/paused/testing/pending/blocked task, or report pending testing status).
-   **Checking Progress:** Use `CWS` during an active session.
-   **Ending Work:** Use `EWS` with the appropriate `Reason`.

## 9. Implementation Examples (Conceptual) (New Section)
*(Self-correction: Revised examples to describe actions instead of using placeholders)*

````javascript
// Example 1: Begin Work Session (BWS) - Conceptual JS
async function handleBWS_Conceptual(sessionType = "FEATURE", targetTaskDetails = null) {
  let scReportData, targetTask;

  if (!targetTaskDetails) {
    // Triggered manually, run SC
    // 1. Read docs/ROADMAP_TASKS.md using read_file tool
    // 2. Search recent Server Memory for TaskCompletion/Error entities using mcp_Server_Memory_search_nodes
    // 3. Parse roadmap and memory data to determine priority task
    // scReportData = parsed result containing priorityTask
    targetTask = scReportData.priorityTask;
    if (!targetTask) {
      console.error("BWS Error: No priority task identified by Status Check.");
      return;
    }
  } else {
    // Triggered by RWS fallback
    targetTask = targetTaskDetails;
  }

  // Determine current task status by reading roadmap or memory
  const currentTaskStatus = "/* Read status (e.g., 'PENDING', 'TESTING') from roadmap/memory */";
  const sessionActualType = (currentTaskStatus === 'TESTING') ? 'TESTING' : sessionType; // Set session type

  // Get timestamp using mcp_mcp_datetime_get_datetime
  const startTime = "/* timestamp from tool */";
  const sessionId = `WS_${sessionActualType}_${startTime.replace(/[-: ]/g, '')}`;

  // Create WorkSession Entity in Server Memory using mcp_Server_Memory_create_entities
  // Include startTime, sessionActualType, targetTask.id, Status: ACTIVE

  // Task Status Update Logic
  if (currentTaskStatus === 'PENDING' || currentTaskStatus === 'BLOCKED') {
    // Update task status to ACTIVE in Server Memory
    // Update docs/ROADMAP_TASKS.md using edit_file to change emoji to 🔄
    // Execute State Synchronization Verification (read memory/file, compare 'ACTIVE'/'🔄')
    "/* Verification logic */";
  } else if (currentTaskStatus === 'TESTING') {
     console.log(`Starting BWS for task ${targetTask.id} already in TESTING (🧪) state.`);
     // Execute State Synchronization Verification (read memory/file, compare 'TESTING'/'🧪')
     "/* Verification logic */";
  } else {
      // Assume already ACTIVE or PAUSED (if resuming via BWS), verify existing state
      // Execute State Synchronization Verification (read memory/file, compare currentStatus/emoji)
      "/* Verification logic */";
  }

  // Perform L1/L3 verification checks (internal logic)
  // Record SESSION_START event (conceptual log)
  console.log(`Session ${sessionId} started for task ${targetTask.id} (${currentTaskStatus})`);
}

// Example 2: Save Work Session (SWS) - Conceptual JS
async function handleSWS_Conceptual(activeSessionId, reason = "Manual Save") {
    // Identify active WorkSession entity in memory
    // Get timestamp using mcp_mcp_datetime_get_datetime
    // Perform L1/L2/L3 checks
    // Generate WSSave ID
    // Attempt to create WSSave entity using mcp_Server_Memory_create_entities
    // Verify creation by reading the new WSSave entity
    // If verification passes:
    //   Update active WorkSession entity status to PAUSED in memory
    //   Update relevant task in docs/ROADMAP_TASKS.md to ⏸️ using edit_file
    //   Execute State Synchronization Verification (compare memory/file 'PAUSED'/'⏸️')
    //   Create relations in memory using mcp_Server_Memory_create_relations
    //   Record SESSION_SAVE event (conceptual log)
    //   Provide feedback with WSSave ID
    // Else:
    //   Report SWS failure
    "/* Detailed logic as described in Section 3.2 */";
}

// Example 3: Resume Work Session (RWS) - Conceptual JS
async function handleRWS_Conceptual(saveSessionId = null) {
  if (saveSessionId) {
    // Attempt to load specific WSSave and linked WorkSession from memory
    // Verify WorkSession status is PAUSED
    // If successful:
    //   Get timestamp
    //   Update WorkSession status to ACTIVE in memory
    //   Update roadmap task from ⏸️ to 🔄 using edit_file
    //   Execute State Synchronization Verification (compare memory/file 'ACTIVE'/'🔄')
    //   Perform L1/L3 checks
    //   Record SESSION_RESUME event
    //   Provide feedback
    //   Return (stop RWS)
    "/* Detailed logic for resuming specific session */";
  }

  // --- Fallback Logic ---
  // Priority 1: Check for Active Blocking Errors
  // Search memory for active Error entities linked to Tasks
  const activeErrorTasks = "/* Result of memory search and relation check */";
  if (activeErrorTasks.length > 0) {
    const targetTask = "/* Select highest priority from activeErrorTasks */";
    console.log(`RWS Fallback: Found active error blocking task ${targetTask.id}. Initiating BWS to resolve.`);
    // Trigger BWS logic (handleBWS_Conceptual) with type "FIX" and targetTask
    return;
  }

  // Priority 2: Check for Paused (⏸️)
  // Read docs/ROADMAP_TASKS.md, parse for ⏸️ tasks
  const pausedTasks = "/* Result of parsing roadmap file */";
  if (pausedTasks.length > 0) {
    const targetTask = "/* Select highest priority from pausedTasks */";
    console.log(`RWS Fallback: Found paused task ${targetTask.id}. Initiating BWS to resume.`);
    // Trigger BWS logic (handleBWS_Conceptual) with type "FEATURE" and targetTask
    return;
  }

  // Priority 3: Check for Testing (🧪)
  // Read docs/ROADMAP_TASKS.md, parse for 🧪 tasks
  const testingTasks = "/* Result of parsing roadmap file */";
  if (testingTasks.length > 0) {
    const targetTask = "/* Select highest priority from testingTasks */";
    console.log(`RWS Fallback: Found testing task ${targetTask.id}. Initiating BWS to continue testing.`);
    // Trigger BWS logic (handleBWS_Conceptual) with type "TESTING" and targetTask
    return;
  }

  // Priority 4: Find Deepest In Progress (🔄)
  // Read docs/ROADMAP_TASKS.md, parse for 🔄 tasks, determine deepest
  const inProgressTasks = "/* Result of parsing roadmap file */";
  if (inProgressTasks.length > 0) {
    const targetTask = "/* Find deepest task from inProgressTasks */";
    console.log(`RWS Fallback: Found deepest active task ${targetTask.id}. Initiating BWS.`);
    // Trigger BWS logic (handleBWS_Conceptual) with type "FEATURE" and targetTask
    return;
  }

  // Priority 5: Check for Pending Testing (🔬)
  // Read docs/ROADMAP_TASKS.md, parse for 🔬 tasks
  const pendingTestTasks = "/* Result of parsing roadmap file */";
  if (pendingTestTasks.length > 0) {
    const targetTask = "/* Select highest priority from pendingTestTasks */";
    console.log(`RWS Halted: Task ${targetTask.id} is pending testing (🔬). Use ST [TaskID] or ST to initiate.`);
    // STOP RWS
    return;
  }

  // Priority 6: Find Highest Priority Pending (⏳)
  // Read docs/ROADMAP_TASKS.md, parse for ⏳ tasks
  const pendingTasks = "/* Result of parsing roadmap file */";
  if (pendingTasks.length > 0) {
    const targetTask = "/* Select highest priority from pendingTasks */";
    console.log(`RWS Fallback: No active/paused/testing tasks. Initiating BWS for pending task ${targetTask.id}.`);
    // Trigger BWS logic (handleBWS_Conceptual) with type "FEATURE" and targetTask
    return;
  }

  // Priority 7: Handle Blocked/No Tasks (❌, None)
  console.log("RWS Halted: No actionable tasks available (Errors/Paused/Testing/Active/Pending).");
  // STOP RWS
  return;
}
````

## 10. Performance & Batching Considerations
*(Self-correction: Restored missing section)*
-   **Memory Queries:** Frequent or complex Server Memory searches (`mcp_Server_Memory_search_nodes`) within fallback logic (especially RWS) can impact performance. Optimize queries where possible.
-   **Roadmap Parsing:** Reading and parsing large roadmap files repeatedly can be inefficient. Consider caching parsed roadmap state internally if performance becomes an issue, but ensure cache invalidation logic is robust.
-   **Batching (Future):** For extremely large projects or complex sessions, consider future enhancements for batching state updates to Server Memory or roadmap files, although this adds significant complexity to state management and error recovery.

