---
description: 
globs: 
alwaysApply: true
---
# Enhanced Work Session Management Protocol (WSMP) v2.9

## 1. Protocol Integration Layer
*(Self-correction: Updated version number and integration points)*
````text
┌─────────────────────────────────────────┐
│         Protocol Integration            │
├─────────────────────────────────────────┤
│ 1. Software Development Meta Protocol   │
│ 2. Rule Execution Protocol              │
│ 3. Task Tracking Protocol               │ // Roadmap Update Logic (Implicit)
│ 4. Memory Maintenance Protocol          │ // Includes Server Memory Rules v2.1+ (Updated)
│ 5. Session Management Protocol (This)   │
│ 6. Status Check Protocol (v2.1+)        │ // Required for BWS context
│ 7. Cross-Protocol Comms & Verification   │
│ 8. Universal Error Resolution Protocol  │
│ 9. Audit Trail System                   │
│ 10. Testing & Verification Protocol v1.3+│ // Handles task verification flow, triggered by EWS
│ 11. Work Session Activation Proto v2.5+ │ // Defines trigger commands (IAW, ST, BWS, EWS, RWS) (Updated)
└─────────────────────────────────────────┘
````

## 2. Activation Commands & Flow
*(Self-correction: Minor clarification on RWS trigger)*
````text
A. Start New Session (BWS)
- Command: "Begin Work Session" or alias "BWS"
- Triggered By: Manual User Command (via WSAP v2.5+) - Requires preceding SC. Can also be triggered internally by RWS fallback.
- Purpose: Initiates a NEW tracked work session, targeting the highest priority task identified by the preceding Status Check or RWS fallback.
- Optional Parameters: Session Type (DEBUG, FEATURE, FIX, REFACTOR).

B. Save Session State (SWS)
- Command: "Save Work Session" or alias "SWS"
- Purpose: Creates a `WorkSessionSave` entity, pauses the active session.
- Optional Parameters: Save Reason.

C. Resume Saved Session (RWS)
- Command: "Resume Work Session" or alias "RWS"
- Triggered By: Manual User Command (via WSAP v2.5+).
- Purpose: Resumes a specific saved session (`[saveSessionID]`) or initiates the hierarchy-aware fallback logic to determine the next action (potentially starting a new BWS or reporting testing status).
- Optional Parameters: `saveSessionID`.

D. End Session (EWS)
- Command: "End Work Session" or alias "EWS"
- Purpose: Formally closes the ACTIVE work session.
- Optional Parameters: Reason (NORMAL, INTERRUPTED, TESTING, COMPLETED, FAILED).

E. Current Session Status & Auto-Save (CWS)
- Command: "Current Working Session" or alias "CWS"
- Purpose: Reports status, summarizes progress, performs auto-save (SWS), resumes (RWS).
- Prerequisites: An active `WorkSession` must exist.
````

## 3. Context Establishment & Session Lifecycle Management

### 3.1 Session Initiation (BWS)
*(No change needed from v2.8)*
1.  **Determine Trigger Source:** BWS is triggered manually by the user or via RWS fallback.
2.  **Acquire Context (Status Check):** Execute "Status Check" (SC v2.1+) *unless* triggered by RWS fallback which has already determined the target.
3.  **Analyze SC Output & Select Target Task:**
    -   If triggered manually: Identify the `🎯 Current / Operational Priority` task from the *newly run* SC report. This is the `targetTask`.
    -   If triggered by RWS fallback: Use the `targetTask` determined by the RWS logic.
4.  **Timestamp:** Get current timestamp (`mcp_mcp_datetime_get_datetime`).
5.  **Generate Session ID:** Create a unique session ID (See Section 5).
6.  **Entity Creation:** Create `WorkSession` entity in Server Memory including:
    - Start timestamp.
    - Session Type (from param or inferred).
    - Target Task ID (`targetTask`).
    - Overall Context (from relevant SC or RWS analysis).
    - Link to the relevant `StatusCheck` entity (if applicable).
    - Status: `ACTIVE`.
7.  **Task Status Update (if applicable):**
    -   If the `targetTask` status was `PENDING` (`⏳`) or `BLOCKED` (`❌` - only if selected due to linked `Error`), update its status to `ACTIVE` (`🔄`) in Server Memory and `docs/ROADMAP_TASKS.md`. Add observation noting the reason (e.g., "Targeting blocked task to resolve error").
    -   **Execute State Synchronization Verification (BWS - Active):** MUST execute the sequence from `Mandatory Post-Update State Synchronization Verification Protocol v1.0` comparing the Memory `Task` status (`ACTIVE`) and the `docs/ROADMAP_TASKS.md` `🔄` marker. Trigger UERP on failure.
8.  **Verification:** Execute L1/L3 Verification Chain checks.
9.  **Audit:** Record `SESSION_START` event in Audit Trail.
10. **Feedback:** Confirm session start with the Session ID, explicitly stating the `targetTask` being worked on.

### 3.2 Save Work Session (SWS)
*(No change needed from v2.8)*
````text
1.  **Identify Active Session:** Determine the currently active `WorkSession` entity. If none, report error.
2.  **Timestamp:** Get current timestamp (`mcp_mcp_datetime_get_datetime`).
3.  **Pre-Save Verification:** Execute L1/L2/L3 Verification Chain checks.
4.  **Generate Save ID:** Create a unique ID for the save state.
5.  **Entity Creation:** Attempt to create the `WorkSessionSave` entity in Server Memory.
6.  **Verify Entity Creation:** Immediately attempt to read the newly created entity.
7.  **Handle Verification Result:** Proceed if successful, abort SWS if failed.
8.  **Update Active Session:** (Only if verification succeeded) Add observation to active `WorkSession` entity: `Session paused by WSSave_[ID] at [Timestamp]`. Change status to `PAUSED`.
9.  **Task Status Marker (Optional but Recommended):** (Only if verification succeeded) Update the primary active task (🔄) in `docs/ROADMAP_TASKS.md` to `⏸️ [Paused: SWS - Timestamp]`.
9.a. **Execute State Synchronization Verification (SWS - Paused):** MUST execute the sequence from `Mandatory Post-Update State Synchronization Verification Protocol v1.0` comparing the Memory `Task` status (paused/linked) and the `docs/ROADMAP_TASKS.md` `⏸️` marker/timestamp. Trigger UERP on failure.
10. **Relation Creation:** (Only if verification succeeded) Link `WorkSessionSave` to relevant entities.
11. **Audit:** Record `SESSION_SAVE` event.
12. **Feedback:** Provide confirmation with `WorkSessionSave` ID.
````

### 3.3 Resume Work Session (RWS)
*(Self-correction: Updated to detail the new hierarchy-aware fallback logic incorporating Error priority)*
````text
1.  **Check for Specific Save ID:** If `saveSessionID` parameter is provided:
    -   Attempt to retrieve the specified `WorkSessionSave` entity and its linked `WorkSession`.
    -   Verify the linked `WorkSession` status is `PAUSED`.
    -   If successful, proceed to Step 7 (Update Work Session for Resumption).
    -   If fails (not found, not paused), report error and proceed to Fallback Logic (Step 2).

2.  **Fallback Logic - Priority 1: Check for Active Blocking Errors:**
    -   Query Server Memory for `Error` entities with `status=active`.
    -   Check for explicit `blockedBy` relations linking active errors to non-`✅` `Task` entities.
    -   If found: Select the highest priority blocked task (`targetTask`). Proceed to Step 6 (Initiate BWS for Fallback).
    -   If not found, proceed to Step 3.

3.  **Fallback Logic - Priority 2: Check for Explicitly Paused (`⏸️`):**
    -   Scan `docs/ROADMAP_TASKS.md` for any task marked `⏸️`.
    -   If found: Select the highest priority one (`targetTask`). Proceed to Step 6 (Initiate BWS for Fallback).
    -   If not found, proceed to Step 4.

4.  **Fallback Logic - Priority 3: Check for Actively Testing (`🧪`):**
    -   Scan `docs/ROADMAP_TASKS.md` for any task marked `🧪`.
    -   If found: Select the highest priority one. **Report** its status (e.g., "`Task X` is actively testing (`🧪`). Awaiting user approval (`AC`/`RC`).") and **stop the RWS process.**
    -   If not found, proceed to Step 5.

5.  **Fallback Logic - Priority 4: Find Deepest "In Progress" (`🔄`):**
    -   Scan `docs/ROADMAP_TASKS.md` for all tasks marked `🔄`.
    -   Select the `🔄` task that is **lowest/deepest** in the hierarchy (`targetTask`).
    -   If found: Proceed to Step 6 (Initiate BWS for Fallback).
    -   If not found, proceed to Step 5a.

5a. **Fallback Logic - Priority 5: Check for Pending Testing (`🔬`):**
    -   Scan `docs/ROADMAP_TASKS.md` for any task marked `🔬`.
    -   If found: Select the highest priority one. **Report** its status (e.g., "`Task Y` is pending testing (`🔬`). Use `ST [TaskID]` or `ST` to initiate.") and **stop the RWS process.**
    -   If not found, proceed to Step 5b.

5b. **Fallback Logic - Priority 6: Find Highest Priority "Pending" (`⏳`):**
    -   Scan `docs/ROADMAP_TASKS.md` for tasks marked `⏳`.
    -   Select the highest priority one (`targetTask`).
    -   If found: Proceed to Step 6 (Initiate BWS for Fallback).
    -   If not found, proceed to Step 5c.

5c. **Fallback Logic - Priority 7: Handle Blocked/No Tasks (`❌`, None):**
    -   If only `❌` (without active linked error) or `✅` tasks remain, **Report** that no actionable tasks are available and **stop the RWS process.**

6.  **Initiate BWS for Fallback:** (If Steps 2, 3, 5, or 5b identified a `targetTask`)
    -   Execute the logic from Section 3.1 (BWS), passing the determined `targetTask`. This will create a *new* `WorkSession` entity focused on the identified task. Stop RWS execution here, as BWS takes over.

7.  **Update Work Session for Resumption:** (If Step 1 successfully found a specific `saveSessionID` and paused session)
    -   Retrieve the linked `WorkSession` entity.
    -   Timestamp: Get current timestamp.
    -   Update `WorkSession` status back to `ACTIVE`. Add observation about resumption referencing the `saveSessionID`.
    -   Restore Context (Informational): Log restored context.
    -   Task Status Marker Update: Update roadmap task marker from `⏸️` back to `🔄`.
    -   **Execute State Synchronization Verification (RWS - Active):** MUST execute the sequence from `Mandatory Post-Update State Synchronization Verification Protocol v1.0` comparing the Memory `Task` status (`ACTIVE`) and the `docs/ROADMAP_TASKS.md` `🔄` marker. Trigger UERP on failure.
    -   Verification: Execute L1/L3 Verification Chain checks.
    -   Audit: Record `SESSION_RESUME`.
    -   Feedback: Confirm session resumption, stating Session ID and priority task.
````

### 3.4 End Work Session (EWS)
*(No change needed from v2.8)*
````text
1.  **Identify Active Session:** Determine the currently active `WorkSession` entity. Stop if none.
2.  **Identify Primary Task:** Identify the primary `Task` entity being worked on. Verify it's `ACTIVE` (`🔄`). Stop if not.
3.  **Timestamp:** Get current timestamp.
4.  **Finalization Logic:** Based on the `Reason` parameter:
    -   **If `Reason` is `TESTING`:**
        -   **Trigger Testing Protocol (Step 1 - Auto-Initiation):** Execute the initial steps of `Testing & Verification Protocol v1.3+` for the primary task. This updates task to `PENDING_TESTING` (`🔬`), creates `VerificationRequest`, executes state sync verification, logs audit, and notifies user.
        -   **Update Work Session:** Change `WorkSession` status to `ENDED`. Add observation: `Session ended. Reason: Development complete, task '[TaskID]' moved to PENDING_TESTING (🔬).`. Set `endTime`.
        -   **Audit:** Record `SESSION_END`.
        -   **Feedback:** Confirm session end, task now pending testing (`ST`).
    -   **If `Reason` is `COMPLETED`:**
        -   **Re-Verify Approval Status (MUST):** Query Server Memory for the `VerificationRequest` linked to the primary `TaskID`. Verify its status is `APPROVED`. Halt/UERP if verification fails.
        -   **(Task Status handled by TVP):** The task status (`COMPLETED`, `✅`) should have already been set by `TVP v1.3+` upon user approval (`AC`). This step mainly finalizes the session context.
        -   **Update Documentation:** Update final documentation (`DEPLOYMENT_CHECKLIST.md`, etc.).
        -   **Update Work Session:** Change status to `ENDED`. Add observation: `Session ended. Reason: Task '[TaskID]' COMPLETED (verified).`. Set `endTime`.
        -   **Audit:** Record `SESSION_END`.
        -   **Feedback:** Confirm session end and task completion.
    -   **If `Reason` is `NORMAL`, `INTERRUPTED`, `FAILED`:**
        -   **Task Status:** Do not change primary task status (remains `🔄` or `ERROR`). Add notes.
        -   **Update Work Session:** Change status to `ENDED`. Add observation: `Session ended. Reason: [Reason Param]`. Set `endTime`.
        -   **Audit:** Record `SESSION_END`.
        -   **Feedback:** Confirm session end, note reason and unchanged task status.
5.  **Verification:** Execute final L1/L2/L4 Verification Chain checks.
````

### 3.5 Current Working Session (CWS)
*(No change needed from v2.8)*
````text
1.  **Identify Active Session:** Stop if none.
2.  **Timestamp:** Get current timestamp.
3.  **Gather Session Info:** Retrieve ID, Start Time, Type, Priority, Context.
4.  **Summarize Session Progress:** Query Memory for entities created after session start and linked to the session. Summarize findings.
5.  **Format Report:** Compile info into user report.
6.  **Trigger Auto-Save (SWS):** Execute SWS logic (Section 3.2) with reason "Auto-save via CWS". Record Save ID.
7.  **Trigger Auto-Resume (RWS):** Execute RWS logic (Section 3.3) using the Save ID from the previous step.
8.  **Verification:** Ensure session status is correctly restored to `ACTIVE` after SWS/RWS cycle.
9.  **Audit:** Record `SESSION_STATUS_CHECK`, `SESSION_SAVE`, `SESSION_RESUME` events.
10. **Feedback:** Present the formatted report (from step 5) to the user.
````

## 4. State Management & Synchronization
*(Self-correction: Added Error state consideration)*
- Manages `WorkSession` entity states (`ACTIVE`, `PAUSED`, `ENDED`).
- Creates/Manages `WorkSessionSave` entities.
- Coordinates with Task Tracking Protocol for roadmap updates (`🔄`, `⏸️`, `✅`, `🔬`, `🧪`, `❌`).
- Utilizes Server Memory for session context, state persistence, and `Error` entity status.
- Employs Cross-Protocol Verification to ensure consistency.

## 5. Session Identification & Naming
*(No change needed from v2.8)*
- **Session ID:** `WS_[Type]_[Timestamp(log_compact)]` (e.g., `WS_Feature_20240331_153100`)
- **Save ID:** `WSSave_[SessionIDShort]_[Timestamp(log_compact)]` (e.g., `WSSave_WSF240331_20240331_170000`)

## 6. Error Handling & Recovery (UERP Integration)
*(Self-correction: Added Error handling in RWS)*
- Handles errors like no active session, failed verification, failed entity creation/read during SWS.
- Uses UERP for critical failures.
- SWS includes verification step to prevent entering paused state if save failed.
- RWS includes comprehensive fallback logic for missing save states, inconsistencies, and prioritizes active blocking errors.

## 7. Verification Checklist (for this protocol)
*(Self-correction: Updated checks for v2.9)*
-   [ ] `BWS` logic accommodates being triggered by RWS fallback.
-   [ ] `BWS` correctly updates status for tasks starting from `⏳` or `❌` (due to error).
-   [ ] `SWS` logic unchanged.
-   [ ] `RWS` logic updated with new hierarchy-aware fallback (`Error` -> `⏸️` -> `🧪` (report/stop) -> `🔄` (deepest) -> `🔬` (report/stop) -> `⏳` -> `❌`).
-   [ ] `RWS` correctly stops and reports status for `🧪` and `🔬` states during fallback.
-   [ ] `RWS` correctly triggers `BWS` when fallback selects `Error`, `⏸️`, `🔄`, or `⏳`.
-   [ ] `EWS` logic unchanged.
-   [ ] State Synchronization Verification is executed at all required points.
-   [ ] Protocol integration layer lists correct protocol versions (`SC v2.1+`, `TVP v1.3+`, `WSAP v2.5+`, `Memory v2.1+`).
-   [ ] Formatting adheres to `rule-formatting-protocol.mdc`.

## 8. Usage Instructions (New Section)
*(Self-correction: Updated RWS description)*
-   **Starting Work:** Always initiate workflow with `IAW` first. Then, use `RWS` (which handles complex fallback including error checking, resuming paused/active work, or starting pending tasks), or use `BWS` directly *after* `SC` if you want to manually target the top priority from the status check.
-   **Interruptions:** Use `SWS` to pause work safely.
-   **Resuming Work:** Use `RWS`. If a specific save state is known, provide its ID (`RWS [saveSessionID]`); otherwise, the protocol executes the full fallback logic to determine the best action (resume, start new, or report testing status).
-   **Checking Progress:** Use `CWS` during an active session.
-   **Ending Work:** Use `EWS` with the appropriate `Reason`.

## 9. Implementation Examples (Conceptual) (New Section)
*(Self-correction: Added RWS Fallback conceptual example)*

````javascript
// Example 1: Begin Work Session (BWS) - Conceptual JS (Unchanged)
async function handleBWS(sessionType = "FEATURE", targetTaskDetails = null) {
  let scReport, targetTask;

  if (!targetTaskDetails) {
    // Triggered manually, run SC
    scReport = await executeProjectStatusCheck(); // Assumes SC returns structured data
    targetTask = scReport.priorityTask;
    if (!targetTask) {
      console.error("BWS Error: No priority task identified by Status Check.");
      return;
    }
  } else {
    // Triggered by RWS fallback
    targetTask = targetTaskDetails;
  }

  // ... (rest of BWS logic from v2.8 example) ...
}

// Example 2: Save Work Session (SWS) - Conceptual JS (Unchanged)
async function handleSWS(activeSessionId, reason = "Manual Save") {
  // ... (SWS logic from v2.8 example) ...
}

// Example 3: Resume Work Session (RWS) - Conceptual JS
async function handleRWS(saveSessionId = null) {
  if (saveSessionId) {
    // Attempt to load specific save state...
    // If successful, update WorkSession, roadmap, verify, audit, feedback (Step 7 logic)
    // If fails, fall through to fallback logic
  }

  // --- Fallback Logic ---
  // Priority 1: Check for Active Blocking Errors
  const activeErrorTasks = await findTasksBlockedByActiveErrors(); // Query Memory
  if (activeErrorTasks.length > 0) {
    const targetTask = selectHighestPriorityTask(activeErrorTasks);
    console.log(`RWS Fallback: Found active error blocking task ${targetTask.id}. Initiating BWS to resolve.`);
    await handleBWS("FIX", targetTask); // Start BWS for the blocked task
    return;
  }

  // Priority 2: Check for Paused (⏸️)
  const pausedTasks = await findTasksByStatusFromRoadmap('⏸️');
  if (pausedTasks.length > 0) {
    const targetTask = selectHighestPriorityTask(pausedTasks);
    console.log(`RWS Fallback: Found paused task ${targetTask.id}. Initiating BWS to resume.`);
    await handleBWS("FEATURE", targetTask); // Start BWS for the paused task
    return;
  }

  // Priority 3: Check for Testing (🧪)
  const testingTasks = await findTasksByStatusFromRoadmap('🧪');
  if (testingTasks.length > 0) {
    const targetTask = selectHighestPriorityTask(testingTasks);
    console.log(`RWS Halted: Task ${targetTask.id} is actively testing (🧪). Awaiting user approval (AC/RC).`);
    // STOP RWS
    return;
  }

  // Priority 4: Find Deepest In Progress (🔄)
  const inProgressTasks = await findTasksByStatusFromRoadmap('🔄');
  if (inProgressTasks.length > 0) {
    const targetTask = findDeepestTask(inProgressTasks); // Logic needed here
    console.log(`RWS Fallback: Found deepest active task ${targetTask.id}. Initiating BWS.`);
    await handleBWS("FEATURE", targetTask); // Start BWS for the deepest active task
    return;
  }

  // Priority 5: Check for Pending Testing (🔬)
  const pendingTestTasks = await findTasksByStatusFromRoadmap('🔬');
  if (pendingTestTasks.length > 0) {
    const targetTask = selectHighestPriorityTask(pendingTestTasks);
    console.log(`RWS Halted: Task ${targetTask.id} is pending testing (🔬). Use ST [TaskID] or ST to initiate.`);
    // STOP RWS
    return;
  }

  // Priority 6: Find Highest Priority Pending (⏳)
  const pendingTasks = await findTasksByStatusFromRoadmap('⏳');
  if (pendingTasks.length > 0) {
    const targetTask = selectHighestPriorityTask(pendingTasks);
    console.log(`RWS Fallback: No active/paused/testing tasks. Initiating BWS for pending task ${targetTask.id}.`);
    await handleBWS("FEATURE", targetTask); // Start BWS for the next pending task
    return;
  }

  // Priority 7: Handle Blocked/No Tasks
  console.log("RWS: No actionable tasks found to resume or start.");
}

// Helper function placeholders (implementation details omitted)
async function findTasksBlockedByActiveErrors() { /* ... */ }
async function findTasksByStatusFromRoadmap(statusEmoji) { /* ... */ }
function selectHighestPriorityTask(tasks) { /* ... */ }
function findDeepestTask(tasks) { /* ... */ }

````

## 10. Documentation & Maintenance (New Section)
*(No change needed from v2.8)*
-   This protocol document (`work-session-management-protocol.mdc`) MUST be updated if the session lifecycle, commands, or integrations change.
-   Ensure referenced protocols (`SC`, `TVP`, `WSAP`, etc.) are kept up-to-date in the Integration Layer section.
-   Changes to task status representation (e.g., roadmap emojis `🔄`, `⏸️`) MUST be reflected consistently across this protocol, the Task Tracking Protocol, and the Status Check Protocol.
-   Regularly review the RWS fallback logic (Section 3.3) to ensure it correctly handles potential inconsistencies between Server Memory and roadmap states.

