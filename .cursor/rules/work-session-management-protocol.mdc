---
description: 
globs: 
alwaysApply: true
---
# Enhanced Work Session Management Protocol (WSMP) v2.8

## 1. Protocol Integration Layer
*(Self-correction: Updated version number and integration points)*
````text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         Protocol Integration            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 1. Software Development Meta Protocol   ‚îÇ
‚îÇ 2. Rule Execution Protocol              ‚îÇ
‚îÇ 3. Task Tracking Protocol               ‚îÇ // Roadmap Update Logic (Implicit)
‚îÇ 4. Memory Maintenance Protocol          ‚îÇ // Includes Server Memory Rules
‚îÇ 5. Session Management Protocol (This)   ‚îÇ
‚îÇ 6. Status Check Protocol (v2.1+)        ‚îÇ // Required for BWS context
‚îÇ 7. Cross-Protocol Comms & Verification   ‚îÇ
‚îÇ 8. Universal Error Resolution Protocol  ‚îÇ
‚îÇ 9. Audit Trail System                   ‚îÇ
‚îÇ 10. Testing & Verification Protocol v1.3+‚îÇ // Handles task verification flow, triggered by EWS (Updated)
‚îÇ 11. Work Session Activation Proto v2.4+ ‚îÇ // Defines trigger commands (IAW, ST, BWS, EWS) (Updated)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
````

## 2. Activation Commands & Flow
````text
A. Start New Session (BWS)
- Command: "Begin Work Session" or alias "BWS"
- Triggered By: Manual User Command (via WSAP v2.4+) - Requires preceding SC.
- Purpose: Initiates a NEW tracked work session, targeting the highest priority task identified by the preceding Status Check.
- Optional Parameters: Session Type (DEBUG, FEATURE, FIX, REFACTOR).

B. Save Session State (SWS)
- Command: "Save Work Session" or alias "SWS"
- Purpose: Creates a `WorkSessionSave` entity, pauses the active session.
- Optional Parameters: Save Reason.

C. Resume Saved Session (RWS)
- Command: "Resume Work Session" or alias "RWS"
- Purpose: Resumes a previously saved work session or handles fallback logic.
- Optional Parameters: `saveSessionID`.

D. End Session (EWS)
- Command: "End Work Session" or alias "EWS"
- Purpose: Formally closes the ACTIVE work session.
- Optional Parameters: Reason (NORMAL, INTERRUPTED, TESTING, COMPLETED, FAILED).

E. Current Session Status & Auto-Save (CWS)
- Command: "Current Working Session" or alias "CWS"
- Purpose: Reports status, summarizes progress, performs auto-save (SWS), resumes (RWS).
- Prerequisites: An active `WorkSession` must exist.
````

## 3. Context Establishment & Session Lifecycle Management

### 3.1 Session Initiation (BWS)
*(Self-correction: Reverted logic - BWS always runs SC and targets highest priority)*
1.  **Determine Trigger Source:** BWS is triggered manually by the user.
2.  **Acquire Context (Status Check):** Execute "Status Check" (SC v2.1+).
3.  **Analyze SC Output & Select Target Task:**
    -   Identify the `üéØ Current / Operational Priority` task from the *newly run* SC report (using ‚ùå > Error > üî¨ > üß™ > üîÑ > ‚è≥ logic). This is the `targetTask`.
4.  **Timestamp:** Get current timestamp (`mcp_mcp_datetime_get_datetime`).
5.  **Generate Session ID:** Create a unique session ID (See Section 5).
6.  **Entity Creation:** Create `WorkSession` entity in Server Memory including:
    - Start timestamp.
    - Session Type (from param or inferred).
    - Target Task ID (`targetTask`) identified in Step 3.
    - Overall Context (from relevant SC).
    - Link to the relevant `StatusCheck` entity.
    - Status: `ACTIVE`.
7.  **Task Status Update (if applicable):**
    -   If the `targetTask` status was `PENDING` (`‚è≥`), update its status to `ACTIVE` (`üîÑ`) in Server Memory and `docs/ROADMAP_TASKS.md`.
    -   **Execute State Synchronization Verification (BWS - Active):** MUST execute the sequence from `Mandatory Post-Update State Synchronization Verification Protocol v1.0` comparing the Memory `Task` status (`ACTIVE`) and the `docs/ROADMAP_TASKS.md` `üîÑ` marker. Trigger UERP on failure.
8.  **Verification:** Execute L1/L3 Verification Chain checks.
9.  **Audit:** Record `SESSION_START` event in Audit Trail.
10. **Feedback:** Confirm session start with the Session ID, explicitly stating the `targetTask` being worked on.

### 3.2 Save Work Session (SWS)
*(No changes required for this logic based on the request)*
````text
1.  **Identify Active Session:** Determine the currently active `WorkSession` entity. If none, report error.
2.  **Timestamp:** Get current timestamp (`mcp_mcp_datetime_get_datetime`).
3.  **Pre-Save Verification:** Execute L1/L2/L3 Verification Chain checks.
4.  **Generate Save ID:** Create a unique ID for the save state.
5.  **Entity Creation:** Attempt to create the `WorkSessionSave` entity in Server Memory.
6.  **Verify Entity Creation:** Immediately attempt to read the newly created entity.
7.  **Handle Verification Result:** Proceed if successful, abort SWS if failed.
8.  **Update Active Session:** (Only if verification succeeded) Add observation to active `WorkSession` entity: `Session paused by WSSave_[ID] at [Timestamp]`. Change status to `PAUSED`.
9.  **Task Status Marker (Optional but Recommended):** (Only if verification succeeded) Update the primary active task (üîÑ) in `docs/ROADMAP_TASKS.md` to `‚è∏Ô∏è [Paused: SWS - Timestamp]`.
9.a. **Execute State Synchronization Verification (SWS - Paused):** MUST execute the sequence from `Mandatory Post-Update State Synchronization Verification Protocol v1.0` comparing the Memory `Task` status (paused/linked) and the `docs/ROADMAP_TASKS.md` `‚è∏Ô∏è` marker/timestamp. Trigger UERP on failure.
10. **Relation Creation:** (Only if verification succeeded) Link `WorkSessionSave` to relevant entities.
11. **Audit:** Record `SESSION_SAVE` event.
12. **Feedback:** Provide confirmation with `WorkSessionSave` ID.
````

### 3.3 Resume Work Session (RWS)
*(No changes required for this logic based on the request)*
````text
1.  **Identify Target Save State & Initiate Fallback:** Logic to find specific save ID, most recent save, or fallback to roadmap `‚è∏Ô∏è` / `üîÑ` markers, initiating a new session if needed based on deepest paused/in-progress task. Stop if nothing found.
2.  **Retrieve Saved State:** (If save entity found) Get `WorkSessionSave` and linked `WorkSession` ID.
3.  **Retrieve Work Session:** (If save entity found) Fetch linked `WorkSession`. Verify it's `PAUSED`.
4.  **Timestamp:** Get current timestamp.
5.  **Update Work Session:** Change status back to `ACTIVE`. Add observation about resumption/new session start.
6.  **Restore Context (Informational):** Log restored/new context.
7.  **Task Status Marker Update:** Update roadmap task marker back to `üîÑ` if `‚è∏Ô∏è` was used. Ensure target task is `üîÑ` if resuming from marker.
7.a. **Execute State Synchronization Verification (RWS - Active):** MUST execute the sequence from `Mandatory Post-Update State Synchronization Verification Protocol v1.0` comparing the Memory `Task` status (`ACTIVE`) and the `docs/ROADMAP_TASKS.md` `üîÑ` marker. Trigger UERP on failure.
8.  **Verification:** Execute L1/L3 Verification Chain checks.
9.  **Audit:** Record `SESSION_RESUME` or `SESSION_START`.
10. **Feedback:** Confirm session resumption/start, stating Session ID and priority task.
````

### 3.4 End Work Session (EWS)
*(Self-correction: Ensure integration with TVP v1.3+)*
````text
1.  **Identify Active Session:** Determine the currently active `WorkSession` entity. Stop if none.
2.  **Identify Primary Task:** Identify the primary `Task` entity being worked on. Verify it's `ACTIVE` (`üîÑ`). Stop if not.
3.  **Timestamp:** Get current timestamp.
4.  **Finalization Logic:** Based on the `Reason` parameter:
    -   **If `Reason` is `TESTING`:**
        -   **Trigger Testing Protocol (Step 1 - Auto-Initiation):** Execute the initial steps of `Testing & Verification Protocol v1.3+` for the primary task. This updates task to `PENDING_TESTING` (`üî¨`), creates `VerificationRequest`, executes state sync verification, logs audit, and notifies user.
        -   **Update Work Session:** Change `WorkSession` status to `ENDED`. Add observation: `Session ended. Reason: Development complete, task '[TaskID]' moved to PENDING_TESTING (üî¨).`. Set `endTime`.
        -   **Audit:** Record `SESSION_END`.
        -   **Feedback:** Confirm session end, task now pending testing (`ST`).
    -   **If `Reason` is `COMPLETED`:**
        -   **Re-Verify Approval Status (MUST):** Query Server Memory for the `VerificationRequest` linked to the primary `TaskID`. Verify its status is `APPROVED`. Halt/UERP if verification fails.
        -   **(Task Status handled by TVP):** The task status (`COMPLETED`, `‚úÖ`) should have already been set by `TVP v1.3+` upon user approval (`AC`). This step mainly finalizes the session context.
        -   **Update Documentation:** Update final documentation (`DEPLOYMENT_CHECKLIST.md`, etc.).
        -   **Update Work Session:** Change status to `ENDED`. Add observation: `Session ended. Reason: Task '[TaskID]' COMPLETED (verified).`. Set `endTime`.
        -   **Audit:** Record `SESSION_END`.
        -   **Feedback:** Confirm session end and task completion.
    -   **If `Reason` is `NORMAL`, `INTERRUPTED`, `FAILED`:**
        -   **Task Status:** Do not change primary task status (remains `üîÑ` or `ERROR`). Add notes.
        -   **Update Work Session:** Change status to `ENDED`. Add observation: `Session ended. Reason: [Reason Param]`. Set `endTime`.
        -   **Audit:** Record `SESSION_END`.
        -   **Feedback:** Confirm session end, note reason and unchanged task status.
5.  **Verification:** Execute final L1/L2/L4 Verification Chain checks.
````

### 3.5 Current Working Session (CWS)
*(No changes required for this logic based on the request)*
````text
1.  **Identify Active Session:** Stop if none.
2.  **Timestamp:** Get current timestamp.
3.  **Gather Session Info:** Retrieve ID, Start Time, Type, Priority, Context.
4.  **Summarize Session Progress:** Query Memory for entities created after session start and linked to the session. Summarize findings.
5.  **Format Report:** Compile info into user report.
6.  **Trigger Auto-Save (SWS):** Execute SWS logic (Section 3.2) with reason "Auto-save via CWS". Record Save ID.
7.  **Trigger Auto-Resume (RWS):** Execute RWS logic (Section 3.3) using the Save ID from the previous step.
8.  **Verification:** Ensure session status is correctly restored to `ACTIVE` after SWS/RWS cycle.
9.  **Audit:** Record `SESSION_STATUS_CHECK`, `SESSION_SAVE`, `SESSION_RESUME` events.
10. **Feedback:** Present the formatted report (from step 5) to the user.
````

## 4. State Management & Synchronization
*(No changes required for this logic based on the request)*
- Manages `WorkSession` entity states (`ACTIVE`, `PAUSED`, `ENDED`).
- Creates/Manages `WorkSessionSave` entities.
- Coordinates with Task Tracking Protocol for roadmap updates (`üîÑ`, `‚è∏Ô∏è`, `‚úÖ`, `üî¨`, `üß™`).
- Utilizes Server Memory for session context and state persistence.
- Employs Cross-Protocol Verification to ensure consistency.

## 5. Session Identification & Naming
*(Self-correction: No change needed here)*
- **Session ID:** `WS_[Type]_[Timestamp(log_compact)]` (e.g., `WS_Feature_20240331_153100`)
- **Save ID:** `WSSave_[SessionIDShort]_[Timestamp(log_compact)]` (e.g., `WSSave_WSF240331_20240331_170000`)

## 6. Error Handling & Recovery (UERP Integration)
- Handles errors like no active session, failed verification, failed entity creation/read during SWS.
- Uses UERP for critical failures.
- SWS includes verification step to prevent entering paused state if save failed.
- RWS includes fallback logic for missing save states or inconsistencies.

## 7. Verification Checklist (for this protocol)
*(Self-correction: Updated checks for v2.7)*
-   [ ] `BWS` logic requires and uses a preceding `SC` to determine the highest priority `targetTask`.
-   [ ] `BWS` updates task status from `‚è≥` to `üîÑ` if needed and executes state sync verification.
-   [ ] `SWS` includes verification of `WorkSessionSave` entity creation before proceeding.
-   [ ] `SWS` includes optional roadmap marker update (`‚è∏Ô∏è`) and state sync verification.
-   [ ] `RWS` includes fallback logic for missing saves/inconsistencies.
-   [ ] `RWS` includes roadmap marker update (`üîÑ` from `‚è∏Ô∏è`) and state sync verification.
-   [ ] `EWS TESTING` triggers TVP v1.3+ correctly.
-   [ ] `EWS COMPLETED` re-verifies `APPROVED` status from TVP v1.3+.
-   [ ] State Synchronization Verification is executed at all required points (BWS Active, SWS Paused, RWS Active, EWS Testing, EWS Completed).
-   [ ] Protocol integration layer lists correct protocol versions (`SC v2.1+`, `TVP v1.3+`, `WSAP v2.4+`).
-   [ ] Formatting adheres to `rule-formatting-protocol.mdc`.

## 8. Usage Instructions (New Section)
-   **Starting Work:** Always initiate workflow with `IAW` first. Then, either use `ST` (if tasks are `üî¨`) followed by `BWS`, or just `BWS` directly if the priority task is actionable (`üîÑ`, `‚è≥`). `BWS` MUST always be preceded by a `Status Check` (either via `IAW` or run immediately before manual `BWS`).
-   **Interruptions:** Use `SWS` to pause work safely, ensuring state is saved to Server Memory and optionally marked on the roadmap.
-   **Resuming Work:** Use `RWS` to pick up where you left off. If a specific save state is known, provide its ID (`RWS [saveSessionID]`); otherwise, the protocol attempts to find the most recent save or fall back to roadmap markers.
-   **Checking Progress:** Use `CWS` during an active session to get a summary of work done *within that session*, automatically save the current state, and continue working.
-   **Ending Work:** Use `EWS` with the appropriate `Reason`:
    -   `EWS TESTING`: When development is done and the task needs user testing.
    -   `EWS COMPLETED`: Only after the user has approved the task via the Testing & Verification Protocol (`AC [TaskID]`).
    -   `EWS NORMAL`/`INTERRUPTED`/`FAILED`: For other session closing scenarios.

## 9. Implementation Examples (Conceptual) (New Section)

````javascript
// Example 1: Begin Work Session (BWS) - Conceptual JS
async function handleBWS(sessionType = "FEATURE") {
  // Step 2: Acquire Context (Status Check)
  const scReport = await executeProjectStatusCheck(); // Assumes SC returns structured data
  const targetTask = scReport.priorityTask; // Extract priority task ID/Name

  if (!targetTask) {
    console.error("BWS Error: No priority task identified by Status Check.");
    return;
  }

  // Step 4: Timestamp
  const startTime = await mcp_mcp_datetime_get_datetime({ format: "datetime" });
  const logTs = await mcp_mcp_datetime_get_datetime({ format: "log_compact" });

  // Step 5: Generate Session ID
  const sessionId = `WS_${sessionType}_${logTs}`;

  // Step 6: Entity Creation
  await mcp_Server_Memory_create_entities({
    entities: [{
      name: sessionId,
      entityType: "WorkSession",
      observations: [
        `Session started at ${startTime}`,
        `Type: ${sessionType}`,
        `Target Task: ${targetTask.id}`, // Assuming targetTask has an id property
        `Overall Context: ${scReport.overallContext}`, // Assuming SC provides context
        `Linked SC: ${scReport.statusCheckEntityId}` // Assuming SC provides its ID
      ],
      // Store targetTask details directly if needed
      fields: { targetTaskId: targetTask.id, targetTaskStatus: targetTask.status }
    }]
  });
  // ... (Create relations etc.) ...

  // Step 7: Task Status Update (if applicable)
  if (targetTask.status === '‚è≥') {
    // Update Task entity in Memory to ACTIVE
    // Update roadmap file to üîÑ
    // Execute State Synchronization Verification
  }

  // Step 8-10: Verification, Audit, Feedback
  console.log(`Work Session ${sessionId} started for task ${targetTask.id}.`);
}

// Example 2: Save Work Session (SWS) - Conceptual JS
async function handleSWS(activeSessionId, reason = "Manual Save") {
  // Step 1: Identify Active Session (Assume activeSessionId is valid)
  // Step 2: Timestamp
  const saveTime = await mcp_mcp_datetime_get_datetime({ format: "datetime" });
  const logTs = await mcp_mcp_datetime_get_datetime({ format: "log_compact" });
  const sessionShortId = activeSessionId.replace(/[^A-Z0-9]/ig, '').substring(0, 10); // Example short ID

  // Step 3: Pre-Save Verification (Conceptual)
  // Step 4: Generate Save ID
  const saveId = `WSSave_${sessionShortId}_${logTs}`;

  // Step 5 & 6: Entity Creation & Verification
  try {
    await mcp_Server_Memory_create_entities({
      entities: [{
        name: saveId,
        entityType: "WorkSessionSave",
        observations: [
          `Session state saved at ${saveTime}`,
          `Reason: ${reason}`,
          `Paused Session: ${activeSessionId}`
          // Add more context like active task, open files etc.
        ]
      }]
    });
    // Attempt to immediately read back the entity to verify creation (not shown)
  } catch (error) {
    console.error(`SWS Error: Failed to create/verify save entity ${saveId}.`, error);
    // Abort SWS
    return;
  }

  // Step 8: Update Active Session
  // Fetch WorkSession entity 'activeSessionId'
  // Add observation: `Session paused by ${saveId} at ${saveTime}`
  // Update status to PAUSED

  // Step 9: Task Status Marker (Optional)
  // Find primary task in roadmap
  // Update marker to ‚è∏Ô∏è [Paused: SWS - saveTime]

  // Step 9a: Execute State Synchronization Verification

  // Step 10: Relation Creation (Link WSSave to WorkSession, Task etc.)

  // Step 11-12: Audit, Feedback
  console.log(`Work Session ${activeSessionId} saved as ${saveId}.`);
}
````

## 10. Documentation & Maintenance (New Section)
-   This protocol document (`work-session-management-protocol.mdc`) MUST be updated if the session lifecycle, commands, or integrations change.
-   Ensure referenced protocols (`SC`, `TVP`, `WSAP`, etc.) are kept up-to-date in the Integration Layer section.
-   Changes to task status representation (e.g., roadmap emojis `üîÑ`, `‚è∏Ô∏è`) MUST be reflected consistently across this protocol, the Task Tracking Protocol, and the Status Check Protocol.
-   Regularly review the RWS fallback logic (Section 3.3) to ensure it correctly handles potential inconsistencies between Server Memory and roadmap states.
