---
description: 
globs: 
alwaysApply: true
---
# Enhanced Work Session Management Protocol (WSMP) v2.3

## 1. Protocol Integration Layer
````text
┌─────────────────────────────────────────┐
│         Protocol Integration            │
├─────────────────────────────────────────┤
│ 1. Software Development Meta Protocol   │
│ 2. Rule Execution Protocol              │
│ 3. Task Tracking Protocol               │ // Roadmap Update Logic (Implicit)
│ 4. Memory Maintenance Protocol          │ // Includes Server Memory Rules
│ 5. Session Management Protocol (This)   │
│ 6. Status Check Protocol                │
│ 7. Cross-Protocol Comms & Verification   │
│ 8. Universal Error Resolution Protocol  │
│ 9. Audit Trail System                   │
└─────────────────────────────────────────┘
````

## 2. Activation Commands & Flow
````text
A. Start New Session
- Command: "Begin Work Session" or alias "BWS"
- Purpose: Initiates a NEW tracked work session.
- Prerequisites: MUST run "Status Check" (SC) immediately prior to BWS.
- Optional Parameters: Session Type (DEBUG, FEATURE, FIX, REFACTOR), Priority Issue (inferred from SC).

B. Save Session State
- Command: "Save Work Session" or alias "SWS"
- Purpose: Creates a `WorkSessionSave` entity, pauses the active session, allowing interruption and later resumption.
- Optional Parameters: Save Reason.

C. Resume Saved Session
- Command: "Resume Work Session" or alias "RWS"
- Purpose: Resumes a previously saved work session, making it active again.
- Optional Parameters: `saveSessionID` (defaults to most recent save).

D. End Session
- Command: "End Work Session" or alias "EWS"
- Purpose: Formally closes the ACTIVE work session, finalizes tasks, updates docs.
- Optional Parameters: Reason (NORMAL, INTERRUPTED, COMPLETED, FAILED).

E. Current Session Status & Auto-Save (NEW)
- Command: "Current Working Session" or alias "CWS"
- Purpose: Reports status of the active session, summarizes progress made within the session, performs an auto-save (SWS), resumes the session (RWS), and allows work to continue.
- Prerequisites: An active `WorkSession` must exist.
````

## 3. Context Establishment & Session Lifecycle Management

### 3.1 Session Initiation (BWS)
````text
1.  **Pre-Check:** Execute "Status Check" (SC).
2.  **Analyze SC Output:** Extract `🎯 Current / Operational Priority` and `⚙️ Overall Context` from the SC report.
3.  **Timestamp:** Get current timestamp (`mcp_mcp_datetime_get_datetime`).
4.  **Generate Session ID:** Create a new, unique session ID following the updated naming convention (See Section 9).
5.  **Entity Creation:** Create `WorkSession` entity in Server Memory with the generated ID, including:
    - Start timestamp.
    - Session Type (from param or inferred).
    - Priority Issue (from SC or parameter).
    - Overall Context (from SC).
    - Link to the preceding `StatusCheck` entity.
    - Status: `ACTIVE`.
6.  **Verification:** Execute L1/L3 Verification Chain checks.
7.  **Audit:** Record `SESSION_START` event in Audit Trail.
8.  **Feedback:** Confirm session start with the new Session ID.
````

### 3.2 Save Work Session (SWS)
````text
1.  **Identify Active Session:** Determine the currently active `WorkSession` entity. If none, report error.
2.  **Timestamp:** Get current timestamp (`mcp_mcp_datetime_get_datetime`).
3.  **Pre-Save Verification:** Execute L1/L2/L3 Verification Chain checks (ensuring state consistency *before* saving).
4.  **Generate Save ID:** Create a unique ID for the save state (e.g., `WSSave_[SessionIDShort]_[Timestamp]`).
5.  **Entity Creation:** Attempt to create the `WorkSessionSave` entity in Server Memory with the generated Save ID, including:
    - Save timestamp.
    - Link to the active `WorkSession` entity ID.
    - Save Reason (if provided).
    - Observations summarizing key state points (e.g., active task ID, relevant open files/entities, current error state if any).
6.  **Verify Entity Creation:** Immediately after step 5, attempt to read the newly created `WorkSessionSave` entity from Server Memory using its generated Save ID.
7.  **Handle Verification Result:**
    - **If Verification SUCCEEDS:** Proceed to step 8.
    - **If Verification FAILS:** Report error "Failed to create/verify WorkSessionSave entity '[SaveID]' in Server Memory. SWS operation aborted, state not saved." DO NOT proceed to step 8. Stop SWS process here.
8.  **Update Active Session:** (Only if step 7 succeeded) Add observation to the active `WorkSession` entity: `Session paused by WSSave_[ID] at [Timestamp]`. Change status to `PAUSED`.
9.  **Task Status Marker (Optional but Recommended):** (Only if step 7 succeeded) Update the primary active task (🔄) in `docs/ROADMAP_TASKS.md` to a "paused" state (e.g., ⏸️ `[Paused: SWS - Timestamp]`) to reflect interruption clearly for the next SC run. This MUST be done consistently if implemented.
10. **Relation Creation:** (Only if step 7 succeeded) Link `WorkSessionSave` entity to relevant `Task`, `Error`, or `Code` entities representing the current state.
11. **Audit:** Record `SESSION_SAVE` event in Audit Trail.
12. **Feedback:** Provide confirmation to the user, including the `WorkSessionSave` entity name/ID.
````

### 3.3 Resume Work Session (RWS)
````text
1.  **Identify Target Save State & Initiate Fallback:**
    - If `saveSessionID` parameter is provided:
      - Search Server Memory for a `WorkSessionSave` entity with that name.
      - If found: Proceed to step 2 (Resume Found Save).
      - If not found: Report error "Specific Save Session ID '[saveSessionID]' not found." and stop.
    - If no `saveSessionID` parameter is provided:
      - Search Server Memory for the most recently created `WorkSessionSave` entity based on timestamp in observations or name.
      - If found: Proceed to step 2 (Resume Found Save).
      - **If no `WorkSessionSave` entity is found:** Proceed to step 1.a (Initiate Fallback Check).

     1.a. **Fallback Check 1: Scan Roadmap for Paused Markers:**
        - Read `docs/ROADMAP_TASKS.md`.
        - Search the content specifically for the `⏸️` emoji marker.
        - **If `⏸️` markers ARE FOUND:**
            - Acknowledge Inconsistency: Report "Inconsistency Detected: Roadmap file shows paused task(s) (marked with ⏸️), but no corresponding 'WorkSessionSave' entity was found in Server Memory. This may indicate a previous Save Work Session (SWS) did not fully complete."
            - Identify Resumption Point: Parse the roadmap structure to identify all tasks marked with `⏸️`. Determine the hierarchical relationship (e.g., based on indentation or task ID structure). Select the task marked with `⏸️` that is deepest in the hierarchy (i.e., the most specific child task).
            - Report Resumption: State "Proceeding by initiating a new session targeting the deepest paused task found: '[Selected Deepest Paused Task Name]'."
            - Initiate New Session: Trigger the logic equivalent to `BWS` (Begin Work Session), creating a *new* `WorkSession` entity. This new session MUST explicitly target the identified deepest paused task as its `Priority Issue`. Link this new `WorkSession` entity to an observation noting the inconsistent state detection and the chosen resumption task. Proceed with the normal RWS flow from step 4 (Timestamp acquisition onwards) using this *newly created* session, effectively resuming work on the target task.
        - **If `⏸️` markers ARE NOT FOUND:** Proceed to step 1.b (Fallback Check 2).

    1.b. **Fallback Check 2: Suggest Last Active Session:**
        - Search Server Memory for the `WorkSession` entity with the latest activity (based on `endTime` or the timestamp of the last observation, prioritizing `endTime` if available).
        - If a recent `WorkSession` is found: Report "No active saved session found to resume. The most recent session activity was for '[Found Session ID]' (Status: [Status], Ended: [End Time/Last Activity Time]). Use BWS to start a new session if intended." and stop.
        - If no `WorkSessionSave` (from initial check) and no recent `WorkSession` entities are found: Report "No saved session or recent activity found. Use BWS to start a new session." and stop.

2.  **Retrieve Saved State:** (Executed only if a `WorkSessionSave` was found in step 1)
    - Get the target `WorkSessionSave` entity and its linked `WorkSession` entity ID.
3.  **Retrieve Work Session:**
    - Fetch the linked `WorkSession` entity. If not found or status is not `PAUSED`, report error "Cannot resume: Linked WorkSession '[SessionID]' not found or not in PAUSED state." and stop.
4.  **Timestamp:** Get current timestamp (`mcp_mcp_datetime_get_datetime`).
5.  **Update Work Session:**
    - Change status back to `ACTIVE`.
    - Add observation: `Session resumed from WSSave_[ID] at [Timestamp]`.
6.  **Restore Context (Informational):**
    - Log the restored context (priority task, overall context) based on the resumed `WorkSession` entity's observations.
7.  **Task Status Marker Update:**
    - If the optional `PAUSED` marker (⏸️) was used in `docs/ROADMAP_TASKS.md` during SWS, update the corresponding task back to `IN_PROGRESS` (🔄). This MUST be done consistently if the marker is used.
8.  **Verification:** Execute L1/L3 Verification Chain checks.
9.  **Audit:** Record `SESSION_RESUME` event in Audit Trail.
10. **Feedback:** Confirm session resumption, stating the active Session ID and the priority task.
````

### 3.4 End Work Session (EWS)
````text
1.  **Identify Active Session:** Determine the currently active `WorkSession` entity. If none, report error.
2.  **Timestamp:** Get current timestamp (`mcp_mcp_datetime_get_datetime`).
3.  **Finalization Logic:** Execute session finalization tasks:
    - Update relevant `Task` entity statuses in Server Memory (e.g., to `COMPLETED`, `PENDING`).
    - Update corresponding tasks in `docs/ROADMAP_TASKS.md` (status emoji, timestamp) via Task Tracking Protocol logic.
    - Update other documentation (`DEPLOYMENT_CHECKLIST.md`, etc.) if needed.
4.  **Update Work Session:**
    - Change status to `ENDED`.
    - Add observation: `Session ended at [Timestamp]. Reason: [Reason Param]`.
    - Set `endTime` field/observation.
5.  **Verification:** Execute final L1/L2/L4 Verification Chain checks.
6.  **Audit:** Record `SESSION_END` event in Audit Trail.
7.  **Feedback:** Confirm session end.
````

### 3.5 Current Working Session (CWS)
````text
1.  **Identify Active Session:** Determine the currently active `WorkSession` entity ID using Server Memory search (e.g., by status='ACTIVE'). If no active session, report error "CWS Error: No active work session found." and stop.
2.  **Timestamp:** Get current timestamp (`mcp_mcp_datetime_get_datetime`, use appropriate formats for reporting and SWS).
3.  **Gather Session Info:** Retrieve basic information from the active `WorkSession` entity:
    - Session ID (Name)
    - Start Time
    - Session Type
    - Initial Priority Issue (from observations)
    - Overall Context (from observations)
4.  **Summarize Session Progress:**
    - Query Server Memory for entities (e.g., `Task`, `Code`, resolved `Error` entities) created *after* the active session's `startTime`.
    - Filter results to include only entities that have a relation linking them *to* the active `WorkSession` entity ID.
    - Generate a concise summary based on these related entities (e.g., "Updated Task X status to Y", "Created Code entity Z for file F", "Resolved Error E"). Handle cases with no significant linked changes gracefully ("No major changes recorded in memory for this session yet.").
5.  **Format Report:** Compile the gathered information (Session ID, Context, Priority, Progress Summary) into a user-facing report.
6.  **Trigger Auto-Save (SWS):** Execute the logic defined in Section 3.2 (Save Work Session) using a specific reason, e.g., "Auto-save via CWS".
    - This creates a `WorkSessionSave` entity.
    - This updates the active `WorkSession` status to `PAUSED`.
    - This may optionally update the roadmap task marker to `⏸️`.
    - Record the generated `WorkSessionSave` entity ID.
7.  **Trigger Auto-Resume (RWS):** Immediately execute the logic defined in Section 3.3 (Resume Work Session).
    - Use the `WorkSessionSave` entity ID created in the previous step as the `saveSessionID` parameter for RWS (or rely on the default behavior if confident it picks the correct one).
    - This updates the `WorkSession` status back to `ACTIVE`.
    - This should update the roadmap task marker back to `🔄` if it was changed by SWS.
8.  **Verification:** Ensure the underlying SWS and RWS steps perform their required Verification Chain checks.
9.  **Audit:** The underlying SWS and RWS calls will trigger `SESSION_SAVE` and `SESSION_RESUME` events. Consider adding a specific `SESSION_STATUS_REPORT` event triggered by CWS itself.
10. **Feedback:** Output the formatted report (from Step 5) to the user, followed by a confirmation message like "Session auto-saved and resumed. Continue workflow."
````

## 4. Save Work Session (SWS) Implementation
````text
1.  **Timestamp:** Get current timestamp (`mcp_mcp_datetime_get_datetime`).
2.  **Verification:** Execute L1/L2/L3 Verification Chain checks (ensuring state consistency *before* saving).
3.  **Entity Creation:** Create `WorkSessionSave` entity in Server Memory, including:
    - Save timestamp.
    - Link to the active `WorkSession` entity.
    - Save Reason (if provided).
    - Observations summarizing key state points (e.g., active task ID, relevant open files/entities, current error state if any).
4.  **Task Status Marker:** Consider updating the primary active task (🔄) in `docs/ROADMAP_TASKS.md` to a "paused" state (e.g., ⏸️ `[Paused: SWS - Timestamp]`) to reflect interruption clearly for the next SC run.
5.  **Relation Creation:** Link `WorkSessionSave` entity to relevant `Task`, `Error`, or `Code` entities representing the current state.
6.  **Audit:** Record `SESSION_SAVE` event in Audit Trail.
7.  **Feedback:** Provide confirmation to the user, including the `WorkSessionSave` entity name/ID for potential future resumption.
````

## 5. Task Status Management Integration
````javascript
// Conceptual Example: Status Updates
class SessionTaskManager {
    async updateTaskStatus(taskId, status, timestamp, sessionId) {
        const statusEmoji = this.getStatusEmoji(status);
        // ... (Update Server Memory) ...
        // Update Roadmap File - Handles PAUSED/ACTIVE transitions
        await this.updateRoadmapFile(taskId, statusEmoji, timestamp, { updatePausedParents: (status === 'ACTIVE') });
    }
    // Ensure this mapping aligns with SC logic
    getStatusEmoji(status) {
        const statusMap = {
            'ACTIVE': '🔄', // Use this for IN_PROGRESS
            'COMPLETED': '✅',
            'BLOCKED': '❌',
            'PENDING': '⏳',
            'PAUSED': '⏸️' // Used by SWS
        };
        return statusMap[status] || '❓';
    }
    async updateRoadmapFile(taskId, emoji, timestamp, options = {}) {
        // Logic to read, find task line, update emoji and timestamp, write file
        // Must be robust to parsing variations used by Status Check
        // Must handle changing ⏸️ back to 🔄 on RWS if that marker is used by SWS.
        // CWS triggers SWS (may set ⏸️) then RWS (should set back to 🔄).
        // If options.updatePausedParents is true, must also find parent tasks
        // in the hierarchy and update their emoji from ⏸️ to 🔄.
    }
}
````

## 6. Verification Chain System Integration
````javascript
// Conceptual Example: Verification during SWS
class SessionVerificationChain {
    async verifyBeforeSave(sessionId) {
        // Ensure protocol states are valid before saving
        await VerificationChainSystem.verifyLevel({ level: 'L1', context: { sessionId } });
        // Ensure data consistency (memory reflects reality) before saving
        await VerificationChainSystem.verifyLevel({ level: 'L2', context: { sessionId } });
        // Ensure system integrity (no dangling locks/resources)
        await VerificationChainSystem.verifyLevel({ level: 'L3', context: { sessionId } });
    }
}
````

## 7. Error Recovery System Integration
````javascript
// Conceptual Example: Handling SWS Failure
class SessionErrorRecovery {
    async handleSaveError(error, sessionId) {
        const recoveryStrategy = await ErrorRecoverySystem.selectStrategy(error);
        await recoveryStrategy.execute({ context: 'SESSION_SAVE', sessionId });
        await this.verifyRecovery(recoveryStrategy);
        // Log detailed error and recovery attempt in audit/memory
        await AuditTrailSystem.record({ /* ... error details ... */ });
        await mcp_Server_Memory_create_entities({ /* ... Error entity ... */ });
    }
}
````

## 8. Audit Trail System Integration
````javascript
// Conceptual Example: Auditing CWS
class SessionAuditTrail {
    async recordSessionEvent(event) {
        const auditSystem = await AuditTrailSystem.getInstance();
        // Record event with full context, including links to relevant entities
        await auditSystem.record({
            timestamp: await mcp_mcp_datetime_get_datetime({ format: "datetime" }),
            sessionId: event.context.sessionId,
            eventType: event.type,
            context: event.context, // e.g., { reason: "Context Switch" } for SWS
            stateSnapshot: await this.captureState(), // Key state points
            relatedEntities: event.relatedEntities // e.g., ['WorkSessionSave_xyz', 'Task_abc']
        });
        await auditSystem.verify(event.id); // Verify record integrity
        // Ensure SESSION_SAVE and SESSION_RESUME are recorded via SWS/RWS calls within CWS.
        // Consider adding: if (event.type === 'CWS') auditSystem.record({ type: 'SESSION_STATUS_REPORT', ... });
    }
}
````

## 9. Entity Naming Convention
*(This section assumes it existed implicitly before and is now formalized, incorporating WSSave)*
````text
- **General:** `[EntityType]_[PrimaryIdentifier/Context]_[Timestamp(log_compact)]`
- **Examples:**
    -   `StatusCheck_SC_20240331_153000`
    -   `WorkSession_FEATURE_AuthModule_20240331_153100`
    -   `Task_ImplementLoginUI_20240331_160000`
    -   `WorkSessionSave_ContextSwitch_20240331_170000`
    -   `Error_DBConnection_20240401_100000`
````

## 10. Potential Improvements & Considerations
````text
1.  **Session Resumption Logic (RWS):** Ensure robust handling of context restoration.
2.  **State Snapshot Granularity (SWS):** Define SWS scope (memory/markers vs. file diffs).
3.  **"Paused" State Handling (SWS/RWS/CWS):** Ensure consistency between SC, roadmap markers (⏸️), and session states, especially the quick PAUSED->ACTIVE transition during CWS.
4.  **Concurrency/Locking:** Implement if needed.
5.  **Save State Cleanup:** Define policy.
6.  **User Feedback:** Enhance confirmations.
7.  **Idempotency:** Design operations safely.
8.  **Visual State Indication:** Consider UI reflection.
9.  **CWS Performance:** The "Summarize Session Progress" step (3.5 Step 4) might be slow if many entities/relations need querying. Optimize memory queries or accept potential latency.
````

## 11. Rationale for v2.3 Changes
- **Added CWS:** Introduced the "Current Working Session" (`CWS`) alias and command in Section 2.
- **Defined CWS Logic:** Created Section 3.5 detailing the steps for CWS, including identifying the active session, gathering info, summarizing progress via Server Memory queries, formatting a report, and orchestrating an auto-save (`SWS`) followed by an auto-resume (`RWS`).
- **Integrated CWS:** Ensured references to underlying SWS/RWS logic and noted interactions with verification, audit trails, and task status markers.
- **Formalized Naming:** Added Section 9 to explicitly define entity naming conventions.
- **Versioning:** Incremented protocol version to v2.3.