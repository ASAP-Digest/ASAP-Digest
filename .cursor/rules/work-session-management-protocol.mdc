---
description: 
globs: 
alwaysApply: true
---
# Enhanced Work Session Management Protocol (WSMP) v2.4

## 1. Protocol Integration Layer
*(Self-correction: Added Testing & Verification Protocol v1.1 to the integration list)*
````text
┌─────────────────────────────────────────┐
│         Protocol Integration            │
├─────────────────────────────────────────┤
│ 1. Software Development Meta Protocol   │
│ 2. Rule Execution Protocol              │
│ 3. Task Tracking Protocol               │ // Roadmap Update Logic (Implicit)
│ 4. Memory Maintenance Protocol          │ // Includes Server Memory Rules
│ 5. Session Management Protocol (This)   │
│ 6. Status Check Protocol                │
│ 7. Cross-Protocol Comms & Verification   │
│ 8. Universal Error Resolution Protocol  │
│ 9. Audit Trail System                   │
│ 10. Testing & Verification Protocol v1.1│ // Handles task verification flow
└─────────────────────────────────────────┘
````

## 2. Activation Commands & Flow
````text
A. Start New Session
- Command: "Begin Work Session" or alias "BWS"
- Purpose: Initiates a NEW tracked work session.
- Prerequisites: MUST run "Status Check" (SC) immediately prior to BWS.
- Optional Parameters: Session Type (DEBUG, FEATURE, FIX, REFACTOR), Priority Issue (inferred from SC).

B. Save Session State
- Command: "Save Work Session" or alias "SWS"
- Purpose: Creates a `WorkSessionSave` entity, pauses the active session, allowing interruption and later resumption.
- Optional Parameters: Save Reason.

C. Resume Saved Session
- Command: "Resume Work Session" or alias "RWS"
- Purpose: Resumes a previously saved work session, making it active again.
- Optional Parameters: `saveSessionID` (defaults to most recent save).

D. End Session
- Command: "End Work Session" or alias "EWS"
- Purpose: Formally closes the ACTIVE work session, finalizes tasks (or transitions them to testing), updates docs.
- Optional Parameters: Reason (NORMAL, INTERRUPTED, TESTING, COMPLETED, FAILED).

E. Current Session Status & Auto-Save
- Command: "Current Working Session" or alias "CWS"
- Purpose: Reports status of the active session, summarizes progress made within the session, performs an auto-save (SWS), resumes the session (RWS), and allows work to continue.
- Prerequisites: An active `WorkSession` must exist.
````

## 3. Context Establishment & Session Lifecycle Management

### 3.1 Session Initiation (BWS)
````text
1.  **Pre-Check:** Execute "Status Check" (SC).
2.  **Analyze SC Output:** Extract `🎯 Current / Operational Priority` and `⚙️ Overall Context` from the SC report.
3.  **Timestamp:** Get current timestamp (`mcp_mcp_datetime_get_datetime`).
4.  **Generate Session ID:** Create a new, unique session ID following the updated naming convention (See Section 9).
5.  **Entity Creation:** Create `WorkSession` entity in Server Memory with the generated ID, including:
    - Start timestamp.
    - Session Type (from param or inferred).
    - Priority Issue (from SC or parameter).
    - Overall Context (from SC).
    - Link to the preceding `StatusCheck` entity.
    - Status: `ACTIVE`.
6.  **Verification:** Execute L1/L3 Verification Chain checks.
7.  **Audit:** Record `SESSION_START` event in Audit Trail.
8.  **Feedback:** Confirm session start with the new Session ID.
````

### 3.2 Save Work Session (SWS)
````text
1.  **Identify Active Session:** Determine the currently active `WorkSession` entity. If none, report error.
2.  **Timestamp:** Get current timestamp (`mcp_mcp_datetime_get_datetime`).
3.  **Pre-Save Verification:** Execute L1/L2/L3 Verification Chain checks (ensuring state consistency *before* saving).
4.  **Generate Save ID:** Create a unique ID for the save state (e.g., `WSSave_[SessionIDShort]_[Timestamp]`).
5.  **Entity Creation:** Attempt to create the `WorkSessionSave` entity in Server Memory with the generated Save ID, including:
    - Save timestamp.
    - Link to the active `WorkSession` entity ID.
    - Save Reason (if provided).
    - Observations summarizing key state points (e.g., active task ID, relevant open files/entities, current error state if any).
6.  **Verify Entity Creation:** Immediately after step 5, attempt to read the newly created `WorkSessionSave` entity from Server Memory using its generated Save ID.
7.  **Handle Verification Result:**
    - **If Verification SUCCEEDS:** Proceed to step 8.
    - **If Verification FAILS:** Report error "Failed to create/verify WorkSessionSave entity '[SaveID]' in Server Memory. SWS operation aborted, state not saved." DO NOT proceed to step 8. Stop SWS process here.
8.  **Update Active Session:** (Only if step 7 succeeded) Add observation to the active `WorkSession` entity: `Session paused by WSSave_[ID] at [Timestamp]`. Change status to `PAUSED`.
9.  **Task Status Marker (Optional but Recommended):** (Only if step 7 succeeded) Update the primary active task (🔄) in `docs/ROADMAP_TASKS.md` to a "paused" state (e.g., ⏸️ `[Paused: SWS - Timestamp]`) to reflect interruption clearly for the next SC run. This MUST be done consistently if implemented.
10. **Relation Creation:** (Only if step 7 succeeded) Link `WorkSessionSave` entity to relevant `Task`, `Error`, or `Code` entities representing the current state.
11. **Audit:** Record `SESSION_SAVE` event in Audit Trail.
12. **Feedback:** Provide confirmation to the user, including the `WorkSessionSave` entity name/ID.
````

### 3.3 Resume Work Session (RWS)
````text
1.  **Identify Target Save State & Initiate Fallback:**
    - If `saveSessionID` parameter is provided:
      - Search Server Memory for a `WorkSessionSave` entity with that name.
      - If found: Proceed to step 2 (Resume Found Save).
      - If not found: Report error "Specific Save Session ID '[saveSessionID]' not found." and stop.
    - If no `saveSessionID` parameter is provided:
      - Search Server Memory for the most recently created `WorkSessionSave` entity based on timestamp in observations or name.
      - If found: Proceed to step 2 (Resume Found Save).
      - **If no `WorkSessionSave` entity is found:** Proceed to step 1.a (Initiate Fallback Checks).

     1.a. **Fallback Check 1: Scan Roadmap for Paused Markers (`⏸️`):**
        - Read `docs/ROADMAP_TASKS.md`.
        - Search the content specifically for the `⏸️` emoji marker.
        - **If `⏸️` markers ARE FOUND:**
            - Acknowledge Inconsistency: Report "Inconsistency Detected: Roadmap file shows paused task(s) (marked with ⏸️), but no corresponding 'WorkSessionSave' entity was found in Server Memory. This may indicate a previous Save Work Session (SWS) did not fully complete."
            - Identify Resumption Point: Parse the roadmap structure to identify all tasks marked with `⏸️`. Determine the hierarchical relationship (e.g., based on indentation or task ID structure). Select the task marked with `⏸️` that is deepest in the hierarchy (i.e., the most specific child task).
            - Report Resumption: State "Proceeding by initiating a new session targeting the deepest paused task found: '[Selected Deepest Paused Task Name]'."
            - Initiate New Session: Trigger the logic equivalent to `BWS` (Begin Work Session), creating a *new* `WorkSession` entity. This new session MUST explicitly target the identified deepest paused task as its `Priority Issue`. Link this new `WorkSession` entity to an observation noting the inconsistent state detection and the chosen resumption task. Proceed with the normal RWS flow from step 4 (Timestamp acquisition onwards) using this *newly created* session, effectively resuming work on the target task.
        - **If `⏸️` markers ARE NOT FOUND:** Proceed to step 1.b (Fallback Check 2).

     1.b. **Fallback Check 2: Scan Roadmap for In-Progress Markers (`🔄`):**
        - Read `docs/ROADMAP_TASKS.md` (if not already read in 1.a).
        - Search the content specifically for the `🔄` emoji marker.
        - **If `🔄` markers ARE FOUND:**
            - Identify Resumption Point: Parse the roadmap structure to identify all tasks marked with `🔄`. Determine the hierarchical relationship. Select the task marked with `🔄` that is deepest in the hierarchy (i.e., the most specific child task).
            - Report Resumption: State "No saved state or explicitly paused task found. Proceeding by initiating a new session targeting the deepest 'In Progress' task found: '[Selected Deepest In-Progress Task Name]'."
            - Initiate New Session: Trigger the logic equivalent to `BWS` (Begin Work Session), creating a *new* `WorkSession` entity. This new session MUST explicitly target the identified deepest in-progress task as its `Priority Issue`. Proceed with the normal RWS flow from step 4 (Timestamp acquisition onwards) using this *newly created* session.
        - **If `🔄` markers ARE NOT FOUND:** Proceed to step 1.c (Fallback Check 3).

    1.c. **Fallback Check 3: Suggest Last Active Session:**
        - Search Server Memory for the `WorkSession` entity with the latest activity (based on `endTime` or the timestamp of the last observation, prioritizing `endTime` if available).
        - If a recent `WorkSession` is found: Report "No active saved session, paused task, or in-progress task found to resume. The most recent session activity was for '[Found Session ID]' (Status: [Status], Ended: [End Time/Last Activity Time]). Use BWS to start a new session if intended." and stop.
        - If no `WorkSessionSave`, `⏸️` marker, `🔄` marker, or recent `WorkSession` entities are found: Report "No saved session or recent activity found. Use BWS to start a new session." and stop.

2.  **Retrieve Saved State:** (Executed only if a `WorkSessionSave` was found in step 1)
    - Get the target `WorkSessionSave` entity and its linked `WorkSession` entity ID.
3.  **Retrieve Work Session:** (Executed only if a `WorkSessionSave` was found in step 1)
    - Fetch the linked `WorkSession` entity. If not found or status is not `PAUSED`, report error "Cannot resume: Linked WorkSession '[SessionID]' not found or not in PAUSED state." and stop.
4.  **Timestamp:** Get current timestamp (`mcp_mcp_datetime_get_datetime`).
5.  **Update Work Session:**
    - Change status back to `ACTIVE`.
    - Add observation: `Session resumed from WSSave_[ID] at [Timestamp]`. (If resuming from save state)
    - Add observation: `New session started targeting task '[Task Name]' based on [Marker Type: Paused/In-Progress] marker at [Timestamp]`. (If resuming based on roadmap marker)
6.  **Restore Context (Informational):**
    - Log the restored context (priority task, overall context) based on the resumed `WorkSession` entity's observations (if resuming save state) or the newly created session's context (if resuming from marker).
7.  **Task Status Marker Update:**
    - If resuming from a `WorkSessionSave` and the optional `PAUSED` marker (⏸️) was used in `docs/ROADMAP_TASKS.md` during SWS, update the corresponding task back to `IN_PROGRESS` (🔄). This MUST be done consistently if the marker is used.
    - If resuming by creating a new session based on a roadmap marker (`⏸️` or `🔄`), ensure the targeted task in `docs/ROADMAP_TASKS.md` is marked as `IN_PROGRESS` (🔄).
8.  **Verification:** Execute L1/L3 Verification Chain checks.
9.  **Audit:** Record `SESSION_RESUME` event in Audit Trail. (If resuming from save state) or `SESSION_START` (if resuming from marker).
10. **Feedback:** Confirm session resumption or start, stating the active Session ID and the priority task.
````

### 3.4 End Work Session (EWS)
*(Self-correction: Updated EWS flow to integrate TESTING state transition)*
````text
1.  **Identify Active Session:** Determine the currently active `WorkSession` entity. If none, report error "EWS Error: No active work session found." and stop.
2.  **Identify Primary Task:** Identify the primary `Task` entity being worked on during this session (e.g., from the `WorkSession` priority or linked entities). Ensure it's currently in an `ACTIVE` (`🔄`) state. If not, report error "EWS Error: Primary task '[TaskID]' is not in an active state." and stop.
3.  **Timestamp:** Get current timestamp (`mcp_mcp_datetime_get_datetime`).
4.  **Finalization Logic:** Based on the `Reason` parameter:
    -   **If `Reason` is `TESTING`:**
        -   **Trigger Testing Protocol (Step 1 - Auto-Initiation):** Execute the initial steps of the `Testing & Verification Protocol v1.1` for the identified primary task. This involves:
            -   Updating the target `Task` entity status to `PENDING_TESTING` in Server Memory.
            -   Updating the corresponding task line in `docs/ROADMAP_TASKS.md` to use the `🔬` emoji and add a note.
            -   Creating a `VerificationRequest` entity linked to the `Task` with status `PENDING_USER_INITIATION`.
            -   Logging the `TASK_PENDING_TESTING` audit event.
            -   Notifying the user the task is ready for testing and awaits `ST [TaskID]`.
        -   **Update Work Session:** Change the active `WorkSession` status to `ENDED`. Add observation: `Session ended at [Timestamp]. Reason: Development complete, task '[TaskID]' moved to PENDING_TESTING (🔬).`. Set `endTime` field/observation.
        -   **Audit:** Record `SESSION_END` event (in addition to the `TASK_PENDING_TESTING` event triggered by the testing protocol).
        -   **Feedback:** Confirm session end and that the task is now pending user testing initiation.
    -   **If `Reason` is `COMPLETED`:**
        -   **Verify Prerequisites:** Check Server Memory for the `VerificationRequest` entity linked to the primary task. Ensure its status is `APPROVED`. If not found or not approved, report error "EWS Error: Cannot mark task '[TaskID]' as COMPLETED. Testing & Verification protocol has not been successfully completed and approved by the user." and stop.
        -   **Update Task Status:** (Assuming verification passed)
            -   Update relevant `Task` entity status in Server Memory to `COMPLETED`.
            -   Update corresponding task in `docs/ROADMAP_TASKS.md` to `✅` emoji and append completion timestamp (using the timestamp from the user's approval if available, otherwise current EWS timestamp).
        -   **Update Documentation:** Update final documentation (`DEPLOYMENT_CHECKLIST.md`, etc.) as needed.
        -   **Update Work Session:** Change status to `ENDED`. Add observation: `Session ended at [Timestamp]. Reason: Task '[TaskID]' COMPLETED (verified).`. Set `endTime`.
        -   **Audit:** Record `SESSION_END` event. The `TASK_COMPLETED` event should have been recorded by the Testing Protocol upon user approval.
        -   **Feedback:** Confirm session end and task completion.
    -   **If `Reason` is `NORMAL`, `INTERRUPTED`, `FAILED`:**
        -   **Task Status:** Do not change the primary task status (it remains `🔄` or potentially moves to `ERROR` if `FAILED`). Add relevant notes to the task or session observations.
        -   **Update Work Session:** Change status to `ENDED`. Add observation: `Session ended at [Timestamp]. Reason: [Reason Param]`. Set `endTime`.
        -   **Audit:** Record `SESSION_END` event.
        -   **Feedback:** Confirm session end, noting the reason and the unchanged status of the primary task.
5.  **Verification:** Execute final L1/L2/L4 Verification Chain checks relevant to the session ending state (e.g., ensuring memory consistency, audit trail update).
````

### 3.5 Current Working Session (CWS)
````text
1.  **Identify Active Session:** Determine the currently active `WorkSession` entity ID using Server Memory search (e.g., by status='ACTIVE'). If no active session, report error "CWS Error: No active work session found." and stop.
2.  **Timestamp:** Get current timestamp (`mcp_mcp_datetime_get_datetime`, use appropriate formats for reporting and SWS).
3.  **Gather Session Info:** Retrieve basic information from the active `WorkSession` entity:
    - Session ID (Name)
    - Start Time
    - Session Type
    - Initial Priority Issue (from observations)
    - Overall Context (from observations)
4.  **Summarize Session Progress:**
    - Query Server Memory for entities (e.g., `Task`, `Code`, resolved `Error` entities) created *after* the active session's `startTime`.
    - Filter results to include only entities that have a relation linking them *to* the active `WorkSession` entity ID.
    - Generate a concise summary based on these related entities (e.g., "Updated Task X status to Y", "Created Code entity Z for file F", "Resolved Error E"). Handle cases with no significant linked changes gracefully ("No major changes recorded in memory for this session yet.").
5.  **Format Report:** Compile the gathered information (Session ID, Context, Priority, Progress Summary) into a user-facing report.
6.  **Trigger Auto-Save (SWS):** Execute the logic defined in Section 3.2 (Save Work Session) using a specific reason, e.g., "Auto-save via CWS".
    - This creates a `WorkSessionSave` entity.
    - This updates the active `WorkSession` status to `PAUSED`.
    - This may optionally update the roadmap task marker to `⏸️`.
    - Record the generated `WorkSessionSave` entity ID.
7.  **Trigger Auto-Resume (RWS):** Immediately execute the logic defined in Section 3.3 (Resume Work Session).
    - Use the `WorkSessionSave` entity ID created in the previous step as the `saveSessionID` parameter for RWS (or rely on the default behavior if confident it picks the correct one).
    - This updates the `WorkSession` status back to `ACTIVE`.
    - This should update the roadmap task marker back to `🔄` if it was changed by SWS.
8.  **Verification:** Ensure the underlying SWS and RWS steps perform their required Verification Chain checks.
9.  **Audit:** The underlying SWS and RWS calls will trigger `SESSION_SAVE` and `SESSION_RESUME` events. Consider adding a specific `SESSION_STATUS_REPORT` event triggered by CWS itself.
10. **Feedback:** Output the formatted report (from Step 5) to the user, followed by a confirmation message like "Session auto-saved and resumed. Continue workflow."
````

## 4. Save Work Session (SWS) Implementation
*(Self-correction: Renumbered section to 4 from previous version's 4. Renamed from "Implementation" to "Details" for clarity as other sections also contain implementation details)*
````text
1.  **Timestamp:** Get current timestamp (`mcp_mcp_datetime_get_datetime`).
2.  **Verification:** Execute L1/L2/L3 Verification Chain checks (ensuring state consistency *before* saving).
3.  **Entity Creation:** Create `WorkSessionSave` entity in Server Memory, including:
    - Save timestamp.
    - Link to the active `WorkSession` entity.
    - Save Reason (if provided).
    - Observations summarizing key state points (e.g., active task ID, relevant open files/entities, current error state if any).
4.  **Task Status Marker:** Consider updating the primary active task (🔄) in `docs/ROADMAP_TASKS.md` to a "paused" state (e.g., ⏸️ `[Paused: SWS - Timestamp]`) to reflect interruption clearly for the next SC run.
5.  **Relation Creation:** Link `WorkSessionSave` entity to relevant `Task`, `Error`, or `Code` entities representing the current state.
6.  **Audit:** Record `SESSION_SAVE` event in Audit Trail.
7.  **Feedback:** Provide confirmation to the user, including the `WorkSessionSave` entity name/ID for potential future resumption.
````

## 5. Task Status Management Integration
*(Self-correction: Renumbered section to 5. Updated example to include new states)*
````javascript
// Conceptual Example: Status Updates
class SessionTaskManager {
    async updateTaskStatus(taskId, status, timestamp, sessionId) {
        const statusEmoji = this.getStatusEmoji(status);
        // ... (Update Server Memory Task entity status) ...

        // Update Roadmap File - Handles PAUSED/ACTIVE/PENDING_TESTING/TESTING/COMPLETED transitions
        // Note: 'COMPLETED' updates typically happen post-verification approval.
        await this.updateRoadmapFile(taskId, statusEmoji, timestamp, {
            updatePausedParents: (status === 'ACTIVE'), // Unpause parents when resuming
            addNote: (status === 'PENDING_TESTING' || status === 'PAUSED') // Add context note
        });
    }

    // Ensure this mapping aligns with SC and Testing Protocol logic
    getStatusEmoji(status) {
        const statusMap = {
            'ACTIVE': '🔄', // In Progress
            'PENDING_TESTING': '🔬', // Agent complete, awaiting user ST command
            'TESTING': '🧪', // User initiated testing (ST command)
            'COMPLETED': '✅', // User approved (AC command)
            'BLOCKED': '❌',
            'PENDING': '⏳',
            'PAUSED': '⏸️', // Used by SWS
            'REWORK': '🔧'  // Optional: If rejected (RC command)
        };
        return statusMap[status] || '❓';
    }

    async updateRoadmapFile(taskId, emoji, timestamp, options = {}) {
        // Logic to read, find task line, update emoji and timestamp/note, write file.
        // Must handle changing ⏸️ back to 🔄 on RWS if that marker is used by SWS.
        // Must handle changing 🔄 to 🔬 on EWS TESTING.
        // Must handle changing 🔬 to 🧪 on user ST command (Testing Protocol).
        // Must handle changing 🧪 to ✅ on user AC command (Testing Protocol).
        // Must handle changing 🧪 back to 🔄 (or 🔧) on user RC command (Testing Protocol).
        // If options.updatePausedParents, find parent tasks and update ⏸️ to 🔄.
        // If options.addNote, append context like "[Paused: SWS...]" or "[Pending User Testing...]".
    }
}
````

## 6. Verification Chain System Integration
*(Self-correction: Renumbered section to 6)*
````javascript
// Conceptual Example: Verification during SWS
class SessionVerificationChain {
    async verifyBeforeSave(sessionId) {
        // Ensure protocol states are valid before saving
        await VerificationChainSystem.verifyLevel({ level: 'L1', context: { sessionId } });
        // Ensure data consistency (memory reflects reality) before saving
        await VerificationChainSystem.verifyLevel({ level: 'L2', context: { sessionId } });
        // Ensure system integrity (no dangling locks/resources)
        await VerificationChainSystem.verifyLevel({ level: 'L3', context: { sessionId } });
    }
}
````

## 7. Error Recovery System Integration
*(Self-correction: Renumbered section to 7)*
````javascript
// Conceptual Example: Handling SWS Failure
class SessionErrorRecovery {
    async handleSaveError(error, sessionId) {
        const recoveryStrategy = await ErrorRecoverySystem.selectStrategy(error);
        await recoveryStrategy.execute({ context: 'SESSION_SAVE', sessionId });
        await this.verifyRecovery(recoveryStrategy);
        // Log detailed error and recovery attempt using server memory 'Error' entity
    }
}
````

## 8. Audit Trail System Integration
*(Self-correction: Renumbered section to 8)*
````text
- `SESSION_START`: Logged by BWS.
- `SESSION_SAVE`: Logged by SWS.
- `SESSION_RESUME`: Logged by RWS (when resuming from save).
- `SESSION_END`: Logged by EWS.
- `SESSION_STATUS_REPORT`: Logged by CWS.
- (Related events like `TASK_PENDING_TESTING`, `TASK_COMPLETED` are logged by integrated protocols)
````

## 9. Entity Naming Conventions
*(Self-correction: Renumbered section to 9)*
````text
- **WorkSession:** `WS_[Type]_[YYYYMMDD_HHMMSS]` (e.g., `WS_FEATURE_20240727_103000`)
- **WorkSessionSave:** `WSSave_[ShortSessionID]_[YYYYMMDD_HHMMSS]` (e.g., `WSSave_FEAT240727_20240727_114515`)
- **StatusCheck:** `SC_[YYYYMMDD_HHMMSS]`
- **StatusReport:** `SR_[YYYYMMDD_HHMMSS]`
- **VerificationRequest:** `VR_[TaskID]_[YYYYMMDD_HHMMSS]`
````
