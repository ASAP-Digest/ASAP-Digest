---
description: 
globs: 
alwaysApply: true
---
# Enhanced Work Session Management Protocol (WSMP) v2.5

## 1. Protocol Integration Layer
*(Self-correction: Updated version number, no change in layers)*
````text
┌─────────────────────────────────────────┐
│         Protocol Integration            │
├─────────────────────────────────────────┤
│ 1. Software Development Meta Protocol   │
│ 2. Rule Execution Protocol              │
│ 3. Task Tracking Protocol               │ // Roadmap Update Logic (Implicit)
│ 4. Memory Maintenance Protocol          │ // Includes Server Memory Rules
│ 5. Session Management Protocol (This)   │
│ 6. Status Check Protocol (v2.1+)        │ // Updated version requirement
│ 7. Cross-Protocol Comms & Verification   │
│ 8. Universal Error Resolution Protocol  │
│ 9. Audit Trail System                   │
│ 10. Testing & Verification Protocol v1.1│ // Handles task verification flow
└─────────────────────────────────────────┘
````

## 2. Activation Commands & Flow
````text
A. Start New Session
- Command: "Begin Work Session" or alias "BWS"
- Purpose: Initiates a NEW tracked work session.
- Prerequisites: MUST run "Status Check" (SC v2.1+) immediately prior to BWS.
- Optional Parameters: Session Type (DEBUG, FEATURE, FIX, REFACTOR), Priority Issue (inferred from SC).

B. Save Session State
- Command: "Save Work Session" or alias "SWS"
- Purpose: Creates a `WorkSessionSave` entity, pauses the active session, allowing interruption and later resumption.
- Optional Parameters: Save Reason.

C. Resume Saved Session
- Command: "Resume Work Session" or alias "RWS"
- Purpose: Resumes a previously saved work session, making it active again.
- Optional Parameters: `saveSessionID` (defaults to most recent save).

D. End Session
- Command: "End Work Session" or alias "EWS"
- Purpose: Formally closes the ACTIVE work session, finalizes tasks (or transitions them to testing), updates docs.
- Optional Parameters: Reason (NORMAL, INTERRUPTED, TESTING, COMPLETED, FAILED).

E. Current Session Status & Auto-Save
- Command: "Current Working Session" or alias "CWS"
- Purpose: Reports status of the active session, summarizes progress made within the session, performs an auto-save (SWS), resumes the session (RWS), and allows work to continue.
- Prerequisites: An active `WorkSession` must exist.
````

## 3. Context Establishment & Session Lifecycle Management

### 3.1 Session Initiation (BWS)
*(Self-correction: Explicitly mention updated priority analysis for v2.5)*
1.  **Pre-Check:** Execute "Status Check" (SC) - *MUST use v2.1 or later*.
2.  **Analyze SC Output:** Extract `🎯 Current / Operational Priority` (reflecting the new `🔬`/`🧪` logic), `🧪 Testing Pipeline`, and `⚙️ Overall Context` from the SC report.
3.  **Timestamp:** Get current timestamp (`mcp_mcp_datetime_get_datetime`).
4.  **Generate Session ID:** Create a new, unique session ID following the updated naming convention (See Section 9).
5.  **Entity Creation:** Create `WorkSession` entity in Server Memory with the generated ID, including:
    - Start timestamp.
    - Session Type (from param or inferred).
    - Priority Issue (from SC, potentially `🔬` or `🧪` state).
    - Overall Context (from SC).
    - Link to the preceding `StatusCheck` entity.
    - Status: `ACTIVE`.
6.  **Verification:** Execute L1/L3 Verification Chain checks.
7.  **Audit:** Record `SESSION_START` event in Audit Trail.
8.  **Feedback:** Confirm session start with the new Session ID, explicitly stating the priority task identified based on the updated SC logic.

### 3.2 Save Work Session (SWS)
````text
1.  **Identify Active Session:** Determine the currently active `WorkSession` entity. If none, report error.
2.  **Timestamp:** Get current timestamp (`mcp_mcp_datetime_get_datetime`).
3.  **Pre-Save Verification:** Execute L1/L2/L3 Verification Chain checks (ensuring state consistency *before* saving).
4.  **Generate Save ID:** Create a unique ID for the save state (e.g., `WSSave_[SessionIDShort]_[Timestamp]`).
5.  **Entity Creation:** Attempt to create the `WorkSessionSave` entity in Server Memory with the generated Save ID, including:
    - Save timestamp.
    - Link to the active `WorkSession` entity ID.
    - Save Reason (if provided).
    - Observations summarizing key state points (e.g., active task ID, relevant open files/entities, current error state if any).
6.  **Verify Entity Creation:** Immediately after step 5, attempt to read the newly created `WorkSessionSave` entity from Server Memory using its generated Save ID.
7.  **Handle Verification Result:**
    - **If Verification SUCCEEDS:** Proceed to step 8.
    - **If Verification FAILS:** Report error "Failed to create/verify WorkSessionSave entity '[SaveID]' in Server Memory. SWS operation aborted, state not saved." DO NOT proceed to step 8. Stop SWS process here.
8.  **Update Active Session:** (Only if step 7 succeeded) Add observation to the active `WorkSession` entity: `Session paused by WSSave_[ID] at [Timestamp]`. Change status to `PAUSED`.
9.  **Task Status Marker (Optional but Recommended):** (Only if step 7 succeeded) Update the primary active task (🔄) in `docs/ROADMAP_TASKS.md` to a "paused" state (e.g., ⏸️ `[Paused: SWS - Timestamp]`) to reflect interruption clearly for the next SC run. This MUST be done consistently if implemented.
9.a. **Execute State Synchronization Verification (SWS - Paused):** MUST execute the sequence from `Mandatory Post-Update State Synchronization Verification Protocol v1.0` comparing the Memory `Task` status (should reflect being paused/linked to save) and the `docs/ROADMAP_TASKS.md` `⏸️` marker/timestamp. Trigger UERP on failure.
10. **Relation Creation:** (Only if step 7 succeeded) Link `WorkSessionSave` entity to relevant `Task`, `Error`, or `Code` entities representing the current state.
11. **Audit:** Record `SESSION_SAVE` event in Audit Trail.
12. **Feedback:** Provide confirmation to the user, including the `WorkSessionSave` entity name/ID.
````

### 3.3 Resume Work Session (RWS)
*(Self-correction: Minor clarification on fallback logic for v2.5)*
````text
1.  **Identify Target Save State & Initiate Fallback:**
    - If `saveSessionID` parameter is provided:
      - Search Server Memory for a `WorkSessionSave` entity with that name.
      - If found: Proceed to step 2 (Resume Found Save).
      - If not found: Report error "Specific Save Session ID '[saveSessionID]' not found." and stop.
    - If no `saveSessionID` parameter is provided:
      - Search Server Memory for the most recently created `WorkSessionSave` entity based on timestamp in observations or name.
      - If found: Proceed to step 2 (Resume Found Save).
      - **If no `WorkSessionSave` entity is found:** Proceed to step 1.a (Initiate Fallback Checks).

     1.a. **Fallback Check 1: Scan Roadmap for Paused Markers (`⏸️`):**
        - Read `docs/ROADMAP_TASKS.md`.
        - Search the content specifically for the `⏸️` emoji marker.
        - **If `⏸️` markers ARE FOUND:**
            - Acknowledge Inconsistency: Report "Inconsistency Detected: Roadmap file shows paused task(s) (marked with ⏸️), but no corresponding 'WorkSessionSave' entity was found in Server Memory. This may indicate a previous Save Work Session (SWS) did not fully complete."
            - Identify Resumption Point: Parse the roadmap structure to identify all tasks marked with `⏸️`. Determine the hierarchical relationship (e.g., based on indentation or task ID structure). Select the task marked with `⏸️` that is deepest in the hierarchy (i.e., the most specific child task).
            - Report Resumption: State "Proceeding by initiating a new session targeting the deepest paused task found: '[Selected Deepest Paused Task Name]'."
            - Initiate New Session: Trigger the logic equivalent to `BWS` (Begin Work Session), creating a *new* `WorkSession` entity. This new session MUST explicitly target the identified deepest paused task as its `Priority Issue`. Link this new `WorkSession` entity to an observation noting the inconsistent state detection and the chosen resumption task. Proceed with the normal RWS flow from step 4 (Timestamp acquisition onwards) using this *newly created* session, effectively resuming work on the target task.
        - **If `⏸️` markers ARE NOT FOUND:** Proceed to step 1.b (Fallback Check 2).

     1.b. **Fallback Check 2: Scan Roadmap for In-Progress Markers (`🔄`):**
        - Read `docs/ROADMAP_TASKS.md` (if not already read in 1.a).
        - Search the content specifically for the `🔄` emoji marker.
        - **If `🔄` markers ARE FOUND:**
            - Identify Resumption Point: Parse the roadmap structure to identify all tasks marked with `🔄`. Determine the hierarchical relationship. Select the task marked with `🔄` that is deepest in the hierarchy (i.e., the most specific child task).
            - Report Resumption: State "No saved state or explicitly paused task found. Proceeding by initiating a new session targeting the deepest 'In Progress' task found: '[Selected Deepest In-Progress Task Name]'."
            - Initiate New Session: Trigger the logic equivalent to `BWS` (Begin Work Session), creating a *new* `WorkSession` entity. This new session MUST explicitly target the identified deepest in-progress task as its `Priority Issue`. Proceed with the normal RWS flow from step 4 (Timestamp acquisition onwards) using this *newly created* session.
        - **If `🔄` markers ARE NOT FOUND:** Proceed to step 1.c (Fallback Check 3).

    1.c. **Fallback Check 3: Suggest Last Active Session:**
        - Search Server Memory for the `WorkSession` entity with the latest activity (based on `endTime` or the timestamp of the last observation, prioritizing `endTime` if available).
        - If a recent `WorkSession` is found: Report "No active saved session, paused task, or in-progress task found to resume. The most recent session activity was for '[Found Session ID]' (Status: [Status], Ended: [End Time/Last Activity Time]). Use BWS to start a new session if intended." and stop.
        - If no `WorkSessionSave`, `⏸️` marker, `🔄` marker, or recent `WorkSession` entities are found: Report "No saved session or recent activity found. Use BWS to start a new session." and stop.

2.  **Retrieve Saved State:** (Executed only if a `WorkSessionSave` was found in step 1)
    - Get the target `WorkSessionSave` entity and its linked `WorkSession` entity ID.
3.  **Retrieve Work Session:** (Executed only if a `WorkSessionSave` was found in step 1)
    - Fetch the linked `WorkSession` entity. If not found or status is not `PAUSED`, report error "Cannot resume: Linked WorkSession '[SessionID]' not found or not in PAUSED state." and stop.
4.  **Timestamp:** Get current timestamp (`mcp_mcp_datetime_get_datetime`).
5.  **Update Work Session:**
    - Change status back to `ACTIVE`.
    - Add observation: `Session resumed from WSSave_[ID] at [Timestamp]`. (If resuming from save state)
    - Add observation: `New session started targeting task '[Task Name]' based on [Marker Type: Paused/In-Progress] marker at [Timestamp]`. (If resuming based on roadmap marker)
6.  **Restore Context (Informational):**
    - Log the restored context (priority task, overall context) based on the resumed `WorkSession` entity's observations (if resuming save state) or the newly created session's context (if resuming from marker).
7.  **Task Status Marker Update:**
    - If resuming from a `WorkSessionSave` and the optional `PAUSED` marker (⏸️) was used in `docs/ROADMAP_TASKS.md` during SWS, update the corresponding task back to `IN_PROGRESS` (🔄). This MUST be done consistently if the marker is used.
    - If resuming by creating a new session based on a roadmap marker (`⏸️` or `🔄`), ensure the targeted task in `docs/ROADMAP_TASKS.md` is marked as `IN_PROGRESS` (🔄).
7.a. **Execute State Synchronization Verification (RWS - Active):** MUST execute the sequence from `Mandatory Post-Update State Synchronization Verification Protocol v1.0` comparing the Memory `Task` status (should be `ACTIVE`) and the `docs/ROADMAP_TASKS.md` `🔄` marker. Trigger UERP on failure.
8.  **Verification:** Execute L1/L3 Verification Chain checks.
9.  **Audit:** Record `SESSION_RESUME` event in Audit Trail. (If resuming from save state) or `SESSION_START` (if resuming from marker).
10. **Feedback:** Confirm session resumption or start, stating the active Session ID and the priority task (which might have been determined by fallback logic if a new session was started).
````

### 3.4 End Work Session (EWS)
*(Self-correction: No changes needed here based on the request, EWS logic is consistent with TVP v1.1)*
````text
1.  **Identify Active Session:** Determine the currently active `WorkSession` entity. If none, report error "EWS Error: No active work session found." and stop.
2.  **Identify Primary Task:** Identify the primary `Task` entity being worked on during this session (e.g., from the `WorkSession` priority or linked entities). Ensure it's currently in an `ACTIVE` (`🔄`) state. If not, report error "EWS Error: Primary task '[TaskID]' is not in an active state." and stop.
3.  **Timestamp:** Get current timestamp (`mcp_mcp_datetime_get_datetime`).
4.  **Finalization Logic:** Based on the `Reason` parameter:
    -   **If `Reason` is `TESTING`:**
        -   **Trigger Testing Protocol (Step 1 - Auto-Initiation):** Execute the initial steps of the `Testing & Verification Protocol v1.1` for the identified primary task. This involves:
            -   Updating the target `Task` entity status to `PENDING_TESTING` in Server Memory.
            -   Updating the corresponding task line in `docs/ROADMAP_TASKS.md` to use the `🔬` emoji and add a note.
            -   **Execute State Synchronization Verification (EWS - Testing):** MUST execute the sequence from `Mandatory Post-Update State Synchronization Verification Protocol v1.0` comparing the Memory `Task` status (`PENDING_TESTING`) and the `docs/ROADMAP_TASKS.md` `🔬` marker/note. Trigger UERP on failure.
            -   Creating a `VerificationRequest` entity linked to the `Task` with status `PENDING_USER_INITIATION`.
            -   Logging the `TASK_PENDING_TESTING` audit event.
            -   Notifying the user the task is ready for testing and awaits `ST [TaskID]`.
        -   **Update Work Session:** Change the active `WorkSession` status to `ENDED`. Add observation: `Session ended at [Timestamp]. Reason: Development complete, task '[TaskID]' moved to PENDING_TESTING (🔬).`. Set `endTime` field/observation.
        -   **Audit:** Record `SESSION_END` event (in addition to the `TASK_PENDING_TESTING` event triggered by the testing protocol).
        -   **Feedback:** Confirm session end and that the task is now pending user testing initiation.
    -   **If `Reason` is `COMPLETED`:**
        -   **Re-Verify Approval Status (MUST):** Identify the target `TaskID`. Query Server Memory for the `VerificationRequest` entity linked to this `TaskID`. Verify that this entity exists and its status is currently `APPROVED`. If this verification fails, halt execution of the `EWS COMPLETED` logic immediately, report a critical error, and trigger UERP. Do NOT proceed further in this block if verification fails.
        -   **Mandatory Pre-Completion Verification (MUST):** Before executing *any* actions for `EWS COMPLETED`, MUST query Server Memory for the `VerificationRequest` entity linked to the primary `TaskID`. MUST confirm this entity exists AND its status is `APPROVED`. **If this check fails, HALT execution of `EWS COMPLETED`, report the verification failure (violation of TVP), and trigger UERP.** Do NOT proceed. *(Note: The `EWS COMPLETED` reason assumes the task has already passed user verification via TVP (`AC [TaskID]`). Its primary role is session finalization and recording the already-approved completion in the session context.)*
        -   **Update Task Status:** (Assuming verification passed)
            -   Update relevant `Task` entity status in Server Memory to `COMPLETED`.
            -   Update corresponding task in `docs/ROADMAP_TASKS.md` to `✅` emoji and append completion timestamp (using the timestamp from the user's approval if available, otherwise current EWS timestamp).
            -   **Execute State Synchronization Verification (EWS - Completed):** MUST execute the sequence from `Mandatory Post-Update State Synchronization Verification Protocol v1.0` comparing the Memory `Task` status (`COMPLETED`) and the `docs/ROADMAP_TASKS.md` `✅` marker/timestamp. Trigger UERP on failure.
        -   **Update Documentation:** Update final documentation (`DEPLOYMENT_CHECKLIST.md`, etc.) as needed.
        -   **Update Work Session:** Change status to `ENDED`. Add observation: `Session ended at [Timestamp]. Reason: Task '[TaskID]' COMPLETED (verified).`. Set `endTime`.
        -   **Audit:** Record `SESSION_END` event. The `TASK_COMPLETED` event should have been recorded by the Testing Protocol upon user approval.
        -   **Feedback:** Confirm session end and task completion.
    -   **If `Reason` is `NORMAL`, `INTERRUPTED`, `FAILED`:**
        -   **Task Status:** Do not change the primary task status (it remains `🔄` or potentially moves to `ERROR` if `FAILED`). Add relevant notes to the task or session observations.
        -   **Update Work Session:** Change status to `ENDED`. Add observation: `Session ended at [Timestamp]. Reason: [Reason Param]`. Set `endTime`.
        -   **Audit:** Record `SESSION_END` event.
        -   **Feedback:** Confirm session end, noting the reason and the unchanged status of the primary task.
5.  **Verification:** Execute final L1/L2/L4 Verification Chain checks relevant to the session ending state (e.g., ensuring memory consistency, audit trail update).
````

### 3.5 Current Working Session (CWS)
````text
1.  **Identify Active Session:** Determine the currently active `WorkSession` entity ID using Server Memory search (e.g., by status='ACTIVE'). If no active session, report error "CWS Error: No active work session found." and stop.
2.  **Timestamp:** Get current timestamp (`mcp_mcp_datetime_get_datetime`, use appropriate formats for reporting and SWS).
3.  **Gather Session Info:** Retrieve basic information from the active `WorkSession` entity:
    - Session ID (Name)
    - Start Time
    - Session Type
    - Initial Priority Issue (from observations)
    - Overall Context (from observations)
4.  **Summarize Session Progress:**
    - Query Server Memory for entities (e.g., `Task`, `Code`, resolved `Error` entities) created *after* the active session's `startTime`.
    - Filter results to include only entities that have a relation linking them *to* the active `WorkSession` entity ID.
    - Generate a concise summary based on these related entities (e.g., "Updated Task X status to Y", "Created Code entity Z for file F", "Resolved Error E"). Handle cases with no significant linked changes gracefully ("No major changes recorded in memory for this session yet.").
5.  **Format Report:** Compile the gathered information (Session ID, Context, Priority, Progress Summary) into a user-facing report.
6.  **Trigger Auto-Save (SWS):** Execute the logic defined in Section 3.2 (Save Work Session) using a specific reason, e.g., "Auto-save via CWS".
    - This creates a `WorkSessionSave` entity.
    - This updates the active `WorkSession` status to `PAUSED`.
    - This may optionally update the roadmap task marker to `⏸️`.
    - Record the generated `WorkSessionSave` entity ID.
7.  **Trigger Auto-Resume (RWS):** Immediately execute the logic defined in Section 3.3 (Resume Work Session).
    - Use the `WorkSessionSave` entity ID created in the previous step as the `saveSessionID` parameter for RWS (or rely on the default behavior if confident it picks the correct one).
    - This updates the `WorkSession` status back to `ACTIVE`.
    - This should update the roadmap task marker back to `🔄` if it was changed by SWS.
8.  **Verification:** Ensure the underlying SWS and RWS steps perform their required Verification Chain checks.
9.  **Audit:** The underlying SWS and RWS calls will trigger `SESSION_SAVE` and `SESSION_RESUME` events. Consider adding a specific `SESSION_STATUS_REPORT` event triggered by CWS itself.
10. **Feedback:** Output the formatted report (from Step 5) to the user, followed by a confirmation message like "Session auto-saved and resumed. Continue workflow."
````

## 4. Save State Verification & Integrity
````markdown
*(Added reference to new checks)*
- **Pre-Save Checks:** Before executing SWS, run relevant L1/L2/L3 Verification Chain checks to ensure the current state is consistent.
- **Post-Save Verification:** Implement the mandatory verification check in SWS (Step 6 & 7) to confirm the `WorkSessionSave` entity was successfully created in Server Memory before proceeding.
- **Roadmap Sync Check:** Implement the mandatory `State Synchronization Verification` check (Step 9.a in SWS) if using the optional roadmap marker.
````

## 5. Task Status Synchronization (`PAUSED`, `ACTIVE` States)
````markdown
*(Added reference to new checks)*
- **SWS:** When pausing, if the optional roadmap marker (`⏸️`) is used, a `State Synchronization Verification` (Step 9.a) MUST be performed.
- **RWS:** When resuming, update the roadmap marker back to `🔄` (if it was changed) and perform a `State Synchronization Verification` (Step 7.a).
````

## 6. Mandatory Post-Update State Synchronization Verification Protocol v1.0
````markdown
# Mandatory Post-Update State Synchronization Verification Protocol v1.0

## 1. Purpose
This protocol defines the mandatory verification steps required *immediately after* any operation that updates BOTH a `Task` entity's status/timestamp in Server Memory AND the corresponding task line's status emoji/timestamp in `docs/ROADMAP_TASKS.md`. It ensures these two critical state representations remain synchronized.

## 2. Activation
- Triggered automatically by protocols like `work-session-management-protocol.mdc` (specifically within SWS, RWS, EWS TESTING, and EWS COMPLETED steps) and `update-memory.mdc` after they perform parallel updates to Memory and the roadmap file.

## 3. Protocol Integration
- Depends on `Server Memory Rules`, `Task Tracking Protocol` (for understanding roadmap format), `Cross-Protocol Comms & Verification`, and `UERP`.

## 4. Verification Steps
1.  **Identify Target Task:** The calling protocol MUST provide the `TaskID` (or equivalent identifier) of the task whose state was just updated.
2.  **Get Memory State:**
    - Use `mcp_Server_Memory_open_nodes` to fetch the `Task` entity corresponding to the `TaskID`.
    - Extract the *current* `status` field (e.g., `PAUSED`, `ACTIVE`, `PENDING_TESTING`, `COMPLETED`).
    - Extract the *current* `lastUpdateTs` field or relevant timestamp observation.
3.  **Get Roadmap State:**
    - Use `read_file` to read the content of `docs/ROADMAP_TASKS.md`.
    - Use string parsing or regex to locate the line corresponding to the `TaskID`.
    - Extract the *current* status emoji (e.g., `⏸️`, `🔄`, `🔬`, `✅`).
    - Extract the *current* timestamp appended to the line (if any).
4.  **Compare States:**
    - **Status Mapping:** Convert the Memory `status` and the Roadmap `emoji` to a common comparable format based on the defined mapping (e.g., `PAUSED` maps to `⏸️`, `ACTIVE` maps to `🔄`, etc.).
    - **Timestamp Comparison:** Compare the Memory timestamp and the Roadmap timestamp. Allow for minor discrepancies (e.g., a few seconds) due to processing time between updates. Define an acceptable tolerance window (e.g., +/- 10 seconds).
5.  **Verification Outcome:**
    - **SUCCESS:** If the mapped statuses match AND the timestamps are within the tolerance window, the verification passes. Log `STATE_SYNC_VERIFY_PASS` in Audit Trail.
    - **FAILURE:** If the statuses do NOT match OR the timestamps are outside the tolerance window, the verification fails.
        - Log `STATE_SYNC_VERIFY_FAIL` in Audit Trail, including details of the mismatch (Memory vs. Roadmap status/timestamp).
        - **Trigger UERP:** Immediately trigger the `Universal Error Resolution Protocol`, reporting a critical state synchronization failure. Halt the calling protocol's execution flow if appropriate.

## 5. Error Handling
- Handle errors during Memory reads or file reads gracefully, but treat such errors as a verification failure, potentially triggering UERP.
````

## 7. Error Handling & Recovery
````markdown
-   **WSMP Errors:** Use UERP for handling failures during session management (e.g., cannot update Memory, critical verification failures).
-   **Task Errors:** Link `Error` entities to the `WorkSession` if errors occur during task execution within the session.
-   **Inconsistent State:** Failures detected by `Mandatory Post-Update State Synchronization Verification Protocol` MUST trigger UERP.
````

## 8. Session Entity Schema & Naming Convention
````markdown
### 8.1 Entity Types
-   `WorkSession`: Represents an active or ended work period.
-   `WorkSessionSave`: Represents a snapshot of a paused WorkSession.

### 8.2 `WorkSession` Observations/Fields (Examples)
-   `startTime`: ISO 8601 timestamp.
-   `endTime`: ISO 8601 timestamp (set on EWS).
-   `status`: `ACTIVE`, `PAUSED`, `ENDED`.
-   `sessionType`: `DEBUG`, `FEATURE`, `FIX`, `REFACTOR`, `GENERAL`.
-   `priorityTaskID`: Name/ID of the main task focused on.
-   `overallContext`: String describing the broader goal (from SC).
-   `triggeringStatusCheckID`: Name/ID of the SC entity that initiated this session.
-   `linkedSaveStateID`: Name/ID of the `WorkSessionSave` if paused via SWS.
-   `resumedFromSaveStateID`: Name/ID of the `WorkSessionSave` this session was resumed from via RWS.
-   `endReason`: `NORMAL`, `INTERRUPTED`, `TESTING`, `COMPLETED`, `FAILED` (set on EWS).

### 8.3 `WorkSessionSave` Observations/Fields (Examples)
-   `saveTime`: ISO 8601 timestamp.
-   `linkedWorkSessionID`: Name/ID of the `WorkSession` being saved.
-   `saveReason`: String provided during SWS.
-   `activeTaskID`: Name/ID of the task being worked on when saved.
-   `openFiles`: List of relevant file paths (optional).
-   `currentErrorState`: Link to active `Error` entity if applicable.

### 8.4 Naming Convention
-   `WorkSession`: `WS_[Type]_[YYYYMMDD]_[HHMMSS]` (e.g., `WS_FEATURE_20250412_153000`)
-   `WorkSessionSave`: `WSSave_[SessionIDShort]_[YYYYMMDD]_[HHMMSS]` (e.g., `WSSave_WSFEAT250412_20250412_160000`)
````

## 9. Version Control & Documentation
````markdown
-   **Commits:** Recommend committing changes frequently, potentially triggered by `SWS` or `EWS`.
-   **Branching:** Use feature branches aligned with `WorkSession` goals.
-   **Documentation:** `EWS` should trigger updates to relevant documentation (e.g., `ROADMAP_TASKS.md`, `DEPLOYMENT_CHECKLIST.md`).
````

## 10. Mandatory Pre-Completion Verification
````markdown
*(Integrated directly into EWS COMPLETED logic in Section 3.4)*
- Before finalizing a task as `COMPLETED` (✅) via `EWS COMPLETED`, the system MUST re-verify that the associated `VerificationRequest` entity in Server Memory has the status `APPROVED`. This check prevents erroneous completion if the user approval step in the `Testing & Verification Protocol` was somehow bypassed or failed. Failure of this check MUST halt `EWS COMPLETED` and trigger UERP.
````
